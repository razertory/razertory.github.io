---
title: 「读书」反应式设计模式
date: 2019-08-04 10:23:27
tags: [book]
---
> 一直以来我都没有刻意去学设计模式这一块，因为我曾经很偏执认为语言本身的设计会需要人附带出一些[设计模式](https://www.runoob.com/design-pattern/strategy-pattern.html)，特别是以 Java 为主导的 OOP 语言，而这些设计模式出现其实就是让人为了接受这样的语言构造而又不得不学的东西。但是唯独这本书《反应式设计模式》例外。因为我认为「设计模式」应该是语言无关的，所以前者我认为那是一种 coding-pattern 而不是真正的 design-pattern。

## Chapter 1, 2
[反应式宣言](https://www.reactivemanifesto.org/zh-CN) 于 2014 年发布，是移动互联网发展最迅猛的时间段。国内移动互联网的用户量，流量在疯狂增长。在这样的时代背景下，有一波牛逼的工程师为了让自己的系统能够更符合当前的状况以及今后的发展搞出了这么一套准则：

**responsive** `即时响应性`：必须对用户作出响应。当系统有外部调用的时候，应该有且一定有快速，一致的响应时间。这可以作为系统可用性的核心指标。获得这样的特性，本质上就是降低延迟。采用的方法有利用队列、并行化等。整体的设计需要一定程度避免出现`大泥球`，这一点和后来火热的为微服务理念不谋而合。但有时候我们的系统会去集成外部的非反应式的系统，并且我们的系统也依旧需要保持这样的即时响应性。后文提到的资源管理模式，流量控制模式在这种场景下会有所帮助。

**resilent** `回弹性`: 必须对失败作出反应，保持高可用性。软件，硬件，编程人员都可能犯错，出现失误。在很多情况下我们会非常关注一个系统的可靠性 reliability，但是错误总是会不期而至。人们一方面需要去避免错误的发生，另一方面，在反应式宣言中，设计系统应该更加关注发生了错误如何让即时响应性快速恢复。对于软件硬件最普遍的做法是 replication，提供一个副本，由于提供了副本也就意味着可能会有分布式一致性问题，所以又有很多的大佬活跃在分布式存储领域。除了提供副本，还有一种方法就是隔离，这就好比设计大型船舶的船舱是一个个的小舱室互相隔离的，即时船触礁破坏了几个舱室，也不至于导致沉船事故。还有就是熔断，有时候可能因为一些的错误导致某个服务的 API 非常慢，大量的 socket 被无效占用以至于整个服务不可用。这个时候就需要短期内让该 API 立即作出快速失败而不至于影响整个系统。

**elastic** `弹性`: 必须对不同的负载情况作出反应。当系统有更高负载的时候支持自动开启更多资源，相反减少。

**message-driven** `消息驱动`: 必须对输入作出反应。反应式宣言中提到的是反应式系统依赖异步的消息传递。

## Chapter 3
#### 函数式编程
函数式编程的本质是：洞察到程序时间上可以按照纯粹的数学函数来编写；也就是说，每次给这些函数输入相同的内容时，它们将总是返回相同的值，并且不会产生副作用。这样做的好处是代码的编写，编译，分析都可以采用纯粹的逻辑推理来保证正确性。而满足函数式通常需要做到：
1. 函数是一等公民。这一点目前有大量的语言都做到了。流行的比如 JavaScript，Golang。
2. 无副作用，或者叫做引用透明性。如果将一个表达式替换为其求值后的结果，程序的的执行应该不受到影响。

比如对于一个 Java 代码。
```Java
final StringBuffer a = new StringBuffer("foo");
final StringBuffer b = a.reverse();
```
执行之后，b 为 "oof", a 也为 "oof"。而对于别的语言比如 Ruby

```ruby
a = "foo"
b = a.reverse
```
执行之后，b 为 "oof", a 不改变。

#### 并发编程范式
如今并发已经有非常多的做法。最早期的做法就是 1-1 模型，即用户逻辑线程与内核调度的线程一一对应的关系比如 Java，C/C++ 。这样做通常因为需要内核做上下文切换，在并发量大的情况下性能开销会非常大。还有是 N - 1 模型，比如 lua, 这样做可以避开上下文切换带来的开销。并且由于没有实质上的并行，可以避开一切数据竞争的问题。这一点也是我认为 lua 能够在给 nginx、redis 做扩展脚本的时候流行起来的原因。还有一种就是 N - M 模型，比如 Golang 自带的 goroutine 调度器和 Clojure 中的 core.async 库实现。这样的做法当然就是对前两种的取长补短。还有一种就是通过一个线程，然后在循环中给每个要并发执行的逻辑都注册自己的方法，之后再等待回调即可。这样的做法通常叫做事件循环（event loop），在 IO 密集业务中非常适合。

在实际的编码中，方面地编写异步非阻塞的代码通常会用到 Future 和 Promise。一种理解的方式是，Future 是一个和时间解耦的值。即 "Future is a value decoupled from time"。 英文理解这个意个例子思就是，I promise you a future。在未来的某个时间点你就可以通过我 Fulfill the promise 来实现。这个 Promise 只会完成一次。用 Java 举个例子，比方说现在有个方法 `retrive()` 返回某个数据，这个数据存在 DB 中也可能存在缓存中，在缓存中找会比在 DB 中找更快。所以，我需要做的是先从缓存中查找这个数据，如果没有的话就从 DB 中找到。假设简化成方法 `retrieveFromCache()` 和 `retrieveFromDB()`。传统的做法就是

```Java
Object retrive(Object param) {
    Object value = retrieveFromCache(param);

    if (value == null)
      value = retrieveFromDB(param);

    return value;
}
```

如果改成并发调用这两个方法以高性能，那么就需要立即拿到先返回方法的结果。首先可以给 cache 和 db 给自注册一个 future。`cacheFuture` 和 `dbFuture`。这两个 future 都包含各自的方法。然后只需要采用 `CompletableFuture.anyOf(dbFuture, cacheFuture)`即可。如果是 Golang 可以直接用channel 配合 `select` 也行。

由于经常会遇到不同的线程之间在逻辑上会有关联，比方说有时候当某个变量值发生的更改需要别的线程都知晓。在目前，通过共享变量的方式已经被部分替代为传递消息的方式，比如 CSP 编程模型，而这个模型用的最多的就是 Golang 中的 channel。一个 goroutine 只需要把值交给 channel，那么别的 goroutine 就从这个 channel 中获取值，从而达到共享数据的效果。Actor 模型和这一点相似。都是采用`消息传递而非共享变量`的方式。不同的是，在 Actor 模型中，每个并发的逻辑单元被称为一个 actor，每个 actor 有自己独立的邮箱。消息发送者需要知道别的 actor 的地址从而广播出去（至于怎么广播，具体广播给谁会有一定的配置和规则）。这样做相比 CSP 提高了容错性，并且可以跨越实例通信（比如 Erlang 和 Akka），从而有更高的可扩展性。





