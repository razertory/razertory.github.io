---
title: 「读书」反应式设计模式
date: 2019-08-04 10:23:27
tags: [book]
---
> 一直以来我都没有刻意去学设计模式这一块，因为我曾经很偏执认为语言本身的设计会需要人附带出一些[设计模式](https://www.runoob.com/design-pattern/strategy-pattern.html)，特别是以 Java 为主导的 OOP 语言, 而这些设计模式出现其实就是让人为了接受这样的语言构造而又不得不学的东西。但是唯独这本书《反应式设计模式》例外。因为我认为「设计模式」这个词应该是语言无关的, 但是前面的我更加认为那是一种 coding-pattern 而不是 design-pattern。

## Chapter 1, 2
[反应式宣言](https://www.reactivemanifesto.org/zh-CN) 于 2014 年发布，是移动互联网发展最迅猛的时间段。国内移动互联网的用户量，流量在疯狂增长。在这样的时代背景下，有一波牛逼的工程师为了让自己的系统能够更符合当前的状况以及今后的发展搞出了这么一套准则: 

**responsive** `即时响应性`：必须对用户作出响应。当系统有外部调用的时候，应该有且一定有快速，一致的响应时间。这可以作为系统可用性的核心指标。获得这样的特性，本质上就是降低延迟。采用的方法有利用队列、并行化等。整体的设计需要一定程度避免出现`大泥球`，这一点和后来火热的为微服务理念不谋而合。但有时候我们的系统会去集成外部的非反应式的系统，并且我们的系统也依旧需要保持这样的即时响应性。后文提到的资源管理模式，流量控制模式在这种场景下会有所帮助。

**resilent** `回弹性`: 必须对失败作出反应, 保持高可用性。软件，硬件，编程人员都可能犯错，出现失误。在很多情况下我们会关注一个系统的可靠性 reliability，但是错误总是会不期而至。人们一方面需要去避免错误的发生，而在反应式宣言中，设计系统应该更加关注发生了错误如何让即时响应性快速恢复。对于软件硬件最普遍的做法是 replication，提供一个副本，由于提供了副本也就意味着可能会有分布式一致性问题，所以莫前又有很多的大牛活跃在分布式存储领域。无处不在的 trade off。除了提供副本，还有一种方法就是隔离，这就好比设计大型船舶的船舱是一个个的小舱室互相隔离的，即时船触礁破坏了几个舱室，也不至于导致沉船事故。另一方面便是熔断，有时候可能因为一些认为的错误导致某些服务的 API 非常慢，大量的 socket 被无效占用以至于整个服务不可用。这个时候就需要短期内让该 API 立即作出失败而不至于影响整个系统。

**elastic** `弹性`: 必须对不同的负载情况作出反应。当系统有更高负载的时候支持自动开启更多资源，相反减少。

**message-driven** `消息驱动`: 必须对输入作出反应。反应式宣言中提到的是反应式系统依赖异步的消息传递。
