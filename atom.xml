<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Razertory 的技术博客</title>
  
  <subtitle>一曲肝肠断，天涯何处觅知音</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://razertory.me/"/>
  <updated>2020-12-25T06:10:54.918Z</updated>
  <id>https://razertory.me/</id>
  
  <author>
    <name>Razertory</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么使用 base62</title>
    <link href="https://razertory.me/2020/12/25/why-base62/"/>
    <id>https://razertory.me/2020/12/25/why-base62/</id>
    <published>2020-12-25T06:08:22.000Z</published>
    <updated>2020-12-25T06:10:54.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="PathVariable"></a>PathVariable</h3><p>当我们在 Spring Boot 应用中，因为一些强制性的原因，不得不选用 PathVariable 定义的时候，可能会遇到如下问题，假设这个 URI 设计成 api/domain/resource/{name}。</p><ul><li>当 name 是形如 “/文件夹/文件夹/资源” 的时候，由于 Spring Boot 会将 / 用作路由分隔符，这里会出现不能预料的问题</li><li>name 是自定义编码的内容的时候，会不得不用上特殊字符</li></ul><p>具体原因是 Spring Boot 的路由解析严格按照了 RFC 3986 标准设计，这套标准中只有 a..z 和 A..Z 和 0..9 和 -_.~ 以及部分保留字符 ! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ] 被认可。那么当业务中我们需要在路由里面包含了特殊字符的时候，为了不影响路由解析，最常见的做法就是给特殊字符进行编码。常见的有 URL Encode 和 Base64，这两种编码大多数常用的编程语言自带 encode，decode 库。</p><h3 id="URL-Encode"><a href="#URL-Encode" class="headerlink" title="URL Encode"></a>URL Encode</h3><p>URL 编码是浏览器发送数据给服务器时使用的编码，它通常附加在 URL 的参数部分，例如：</p><p><a href="https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87</a></p><p>之所以需要 URL 编码，是因为出于兼容性考虑，很多服务器只识别 ASCII 字符。但如果 URL 中包含中文、日文这些非 ASCII 字符怎么办？不要紧，URL 编码有一套规则：</p><p>如果字符是 A<del>Z，a</del>z，0~9 以及-、_、.、*，则保持不变；<br>如果是其他字符，先转换为 UTF-8 编码，然后对每个字节以%XX 表示。<br>例如：字符中的 UTF-8 编码是 0xe4b8ad，因此，它的 URL 编码是%E4%B8%AD。URL 编码总是大写。</p><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><p>URL 编码是对字符进行编码，表示成%xx 的形式，而 Base64 编码是对二进制数据进行编码，表示成文本格式。</p><p>Base64 编码可以把任意长度的二进制数据变为纯文本，且只包含 A<del>Z、a</del>z、0~9、+、/、=这些字符。它的原理是把 3 字节的二进制数据按 6bit 一组，用 4 个 int 整数表示，然后查表，把 int 整数用索引对应到字符，得到编码后的字符串。</p><h3 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h3><p>根据背景判断，base64 首先需要排除掉，因为其中包含了 / 字符，这对于 PathVariable 来说是非常危险的。只要被编码了之后包含了 / ，比如 “你说这东西” 被编码之后是 “5L2g6K+06L+Z5Lic6KW/“ 这个时候在 api/domain/resource/{name} 设计的 URI 中，就会变成 api/domain/resource/5L2g6K+06L+Z5Lic6KW/，Spring Boot 会默认截断最后一个 / 符号，导致解码异常。</p><p>另一个场景下，URL Encode 也不适用，这里会有一些自定义的编码解码风格，比如 api/domain/resource/{query}, 这个 query 被设计成 “分类-风格-搜索关键词” 的格式，其中“搜索关键词”是用户自定义输入，比如有个资源名叫 “酷大师-最美模型” ，因此这个路由编码之前是 api/domain/resource/分类-风格-酷大师-最美模型，编码之后是 api/domain/resource/%E5%88%86%E7%B1%BB-%E9%A3%8E%E6%A0%BC-%E9%85%B7%E5%A4%A7%E5%B8%88-%E6%9C%80%E7%BE%8E%E6%A8%A1%E5%9E%8B。由于 URL Encode 会保留 - 字符因此当用户的输入带有了保留的特殊字符的时候，会破坏协议本身的语义。</p><h3 id="Base62"><a href="#Base62" class="headerlink" title="Base62"></a>Base62</h3><p>base62 是一种编码之后只包含了 A<del>Z、a</del>z、0~9 62 种字符的编码方式。这种方式可以避开任何符号字符，让 PathVariable 中的变量更加安全。那么选用哪一种 Base62 是最为合适的？</p><p>首先，Java 和 Js 自身的 lib 并不支持 base62 编码，现成的库有不少，但都有各自的实现。为了让前后端统一，我选用了 Base62x: An alternative approach to Base64 for non-alphanumeric characters 的实现，并在前后端各自配置了一套实现。这套算法的 GitHub 仓库是 <a href="https://github.com/wadelau/Base62x" target="_blank" rel="noopener">https://github.com/wadelau/Base62x</a> ，在线 encode/decode 地址是 <a href="https://ufqi.com/dev/base62x/。" target="_blank" rel="noopener">https://ufqi.com/dev/base62x/。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;PathVariable&quot;&gt;&lt;a href=&quot;#PathVariable&quot; class=&quot;headerlink&quot; title=&quot;PathVariable&quot;&gt;&lt;/a&gt;PathVariable&lt;/h3&gt;&lt;p&gt;当我们在 Spring Boot 应用中，因为一些强制性的原
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>改善你的 Go 代码</title>
    <link href="https://razertory.me/2020/07/21/go-coding-skills/"/>
    <id>https://razertory.me/2020/07/21/go-coding-skills/</id>
    <published>2020-07-21T06:29:48.000Z</published>
    <updated>2020-07-21T08:03:51.072Z</updated>
    
    <content type="html"><![CDATA[<p>之前参与翻译了 Uber 公司分享的 Go 语言编码规范。一直以来，我对编码规范的态度是<strong>80%的正确性和20%的一致性</strong>。写代码，重要的是让程序正确和高效以及可维护性。近期整理了工作中遇到的改善 Go 编码的一些案例。</p><h3 id="闭包（Closure）和-defer"><a href="#闭包（Closure）和-defer" class="headerlink" title="闭包（Closure）和 defer"></a>闭包（Closure）和 defer</h3><p>闭包的官方解释是：闭包是由函数和与其相关的引用环境组合而成的实体。defer 可以让一个闭包在函数 return 的时刻调用。比如有一个这样的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">conn := d.redis.Get(ctx)</span><br><span class="line">err := conn.Send(<span class="string">"SADD"</span>)</span><br><span class="line">err = conn.Send(<span class="string">"EXPIRE"</span>)</span><br><span class="line">err = conn.Flush()</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 到 5 行的代码都需要处理 err，同时还需要 conn.Close()。所以可以改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">conn := d.redis.Get(ctx)</span><br><span class="line">err := conn.Send(<span class="string">"SADD"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">err = conn.Send(<span class="string">"EXPIRE"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">err = conn.Flush()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么写阅读起来有太多重复的逻辑，同时修改之后，也容易忘记 conn.Close()。这种情况，可以试着用闭包配合 defer 来改善</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">err := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">conn := d.redis.Get(ctx)</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="keyword">if</span> err := conn.Send(<span class="string">"SADD"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := conn.Send(<span class="string">"EXPIRE"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := conn.Flush(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nil-interface"><a href="#nil-interface" class="headerlink" title="nil interface"></a>nil interface</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Audi <span class="keyword">struct</span> &#123;</span><br><span class="line">price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Tesla <span class="keyword">struct</span> &#123;</span><br><span class="line">price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">car := getCar()</span><br><span class="line"><span class="keyword">if</span> car == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"nil"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%+v is not nil"</span>, car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCar</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;&#123;</span><br><span class="line"><span class="keyword">var</span> audi *Audi</span><br><span class="line"><span class="keyword">var</span> tesla *Tesla</span><br><span class="line"><span class="keyword">if</span> rand.Int63() / <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tesla</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> audi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的输出是 14 行的 <code>&lt;nil&gt; is not nil</code>。针对 interface{} 类型，判断是否 nil 需要判断类型的和值，本质上只要类型存在，比如这里可能是 <code>*Audi</code> 或者 <code>*Tesla</code>，那么就不会为 nil。如果需要设计返回 interface{} 的函数，可以加上一个 ok bool 表示是否存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">car, ok := getCar()</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%+v is not nil"</span>, car)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCar</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> audi *Audi <span class="comment">// 在确定类型的地方，判断是否空，这样再用 bool 类型给到外面</span></span><br><span class="line"><span class="keyword">return</span> audi, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h3><p>named return value 在和 defer 相遇的时候，会有一些需要注意的细节。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">getName()</span><br><span class="line">getName2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span> <span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">name = <span class="string">"john"</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(name)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="string">"jerry"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName2</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">name := <span class="string">"john"</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(name)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> <span class="string">"jerry"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出的是 <code>jerryjohn</code>。如果闭包用到了 named retrun value，就意味着这个值及时没有被明显的复制，比如 <code>return &quot;jerry&quot;</code> 实际上是让 <code>name</code> 这个变量赋值了。这种代码难以 review 和调试。所以在返回值只有一个、两个的时候，推荐不用 named return value。只有返回值多个，或者返回值的类型一样的时候，再推荐 named return value。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>编写生产环境代码的时候，为了让 err 产生的时候，尽量带有更多有利于排查问题的信息，推荐以下方法</p><ul><li>标准库产生的 err，使用 `errors.WithStack()</li><li>除此之外的 err，用 github.com/pkg/errors 中的 Wrapf(), New(), Errorf()</li></ul><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>Go 语言的 for 循环，循环变量实际上<strong>总是指向同一块地址</strong>，在循环过程中，不断进行覆盖值的操作。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr []*<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">arr = <span class="built_in">append</span>(arr, &amp;i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Values:"</span>, *arr[<span class="number">0</span>], *arr[<span class="number">1</span>], *arr[<span class="number">2</span>])</span><br><span class="line">fmt.Println(<span class="string">"Addresses:"</span>, arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是:<br>Values: 3 3 3<br>Addresses: 0xc00001c078 0xc00001c078 0xc00001c078</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前参与翻译了 Uber 公司分享的 Go 语言编码规范。一直以来，我对编码规范的态度是&lt;strong&gt;80%的正确性和20%的一致性&lt;/strong&gt;。写代码，重要的是让程序正确和高效以及可维护性。近期整理了工作中遇到的改善 Go 编码的一些案例。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>按照顺序打印</title>
    <link href="https://razertory.me/2020/06/21/print-in-order/"/>
    <id>https://razertory.me/2020/06/21/print-in-order/</id>
    <published>2020-06-21T02:41:56.000Z</published>
    <updated>2020-06-21T04:15:30.886Z</updated>
    
    <content type="html"><![CDATA[<p>没错，我又开了个坑。这次的问题是 <a href="https://leetcode-cn.com/problems/print-in-order/" target="_blank" rel="noopener">按顺序打印</a>。大意就是有 one two three 三个线程同时在跑，一定要让 two 在 one 后面、three 在 two 后面执行。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>本来觉得用 Go 的 channel 应该是最好写的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oneDone <span class="keyword">chan</span> <span class="comment">//one 结束就 oneDone &lt;-</span></span><br><span class="line"><span class="keyword">var</span> twoDone <span class="keyword">chan</span> <span class="comment">//two 结束就 twoDone &lt;-</span></span><br></pre></td></tr></table></figure><p>可惜并没有 Go。所以，要不 Java ? </p><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>那么要做到和 channel 类似的效果，首先就是确保 BlockingQueue 能在没有元素 pop 的时候能阻塞。查一下 api 有个 take () 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieves and removes the head of this queue, waiting if necessary</span></span><br><span class="line"><span class="comment"> * until an element becomes available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">take</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>已通过代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; one;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; two;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        one = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        two = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span> <span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printFirst.run () outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst.run();</span><br><span class="line">        one.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span> <span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printSecond.run () outputs "second". Do not change or remove this line.</span></span><br><span class="line">        one.take();</span><br><span class="line">        printSecond.run ();</span><br><span class="line">        two.add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span> <span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printThird.run () outputs "third". Do not change or remove this line.</span></span><br><span class="line">        two.take();</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的本质是要在 * 并发执行的过程中，保证部分单元的执行顺序 *。也就是某个执行单元在条件没有达到的时候，保持阻塞，让出 CPU。</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><blockquote><p>信号量（英语：semaphore）又称为信号标，是一个同步对象，用于保持在 0 至指定最大值之间的一个计数值。当线程完成一次对该 semaphore 对象的等待（wait）时，该计数值减一；当线程完成一次对 semaphore 对象的释放（release）时，计数值加一。当计数值为 0，则线程等待该 semaphore 对象不再能成功直至该 semaphore 对象变成 signaled 状态。semaphore 对象的计数值大于 0，为 signaled 状态；计数值等于 0，为 nonsignaled 状态.<br>semaphore 对象适用于控制一个仅支持有限个用户的共享资源，是一种不需要使用忙碌等待（busy waiting）的方法。<br>信号量的概念是由荷兰计算机科学家艾兹赫尔・戴克斯特拉（Edsger W. Dijkstra）发明的，广泛的应用于不同的操作系统中。在系统中，给予每一个进程一个信号量，代表每个进程目前的状态，未得到控制权的进程会在特定地方被强迫停下来，等待可以继续进行的信号到来。如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的 0 或 1，称为二进制信号量（binary semaphore）。在 linux 系统中，二进制信号量（binary semaphore）又称互斥锁（Mutex）。 – 维基百科</p></blockquote><p>Java 里面信号量有两个重要的行为，acquire 和 release。对此分别有以下描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires a permit from this semaphore, blocking until one is</span></span><br><span class="line"><span class="comment"> * available, or the thread is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires a permit, if one is available and returns immediately,</span></span><br><span class="line"><span class="comment"> * reducing the number of available permits by one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no permit is available then the current thread becomes</span></span><br><span class="line"><span class="comment"> * disabled for thread scheduling purposes and lies dormant until</span></span><br><span class="line"><span class="comment"> * one of two things happens:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread invokes the &#123;<span class="doctag">@link</span> #release&#125; method for this</span></span><br><span class="line"><span class="comment"> * semaphore and the current thread is next to be assigned a permit; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span></span><br><span class="line"><span class="comment"> * the current thread.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * for a permit,</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread's</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Releases a permit, returning it to the semaphore.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Releases a permit, increasing the number of available permits by</span></span><br><span class="line"><span class="comment"> * one.  If any threads are trying to acquire a permit, then one is</span></span><br><span class="line"><span class="comment"> * selected and given the permit that was just released.  That thread</span></span><br><span class="line"><span class="comment"> * is (re) enabled for thread scheduling purposes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is no requirement that a thread that releases a permit must</span></span><br><span class="line"><span class="comment"> * have acquired that permit by calling &#123;<span class="doctag">@link</span> #acquire&#125;.</span></span><br><span class="line"><span class="comment"> * Correct usage of a semaphore is established by programming convention</span></span><br><span class="line"><span class="comment"> * in the application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore s1;</span><br><span class="line">    <span class="keyword">private</span> Semaphore s2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">        s2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span> <span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        printFirst.run();</span><br><span class="line">        s1.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span> <span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        s1.acquire();</span><br><span class="line">        printSecond.run();</span><br><span class="line">        s2.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span> <span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        s2.acquire();</span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wait-和-Notify"><a href="#Wait-和-Notify" class="headerlink" title="Wait 和 Notify"></a>Wait 和 Notify</h3><p>先说结论，用这种写法的是 Java 大佬。<a href="https://leetcode-cn.com/problems/print-in-order/solution/gou-zao-zhi-xing-ping-zhang-shi-xian-by-pulsaryu/" target="_blank" rel="noopener">传送门</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> firstFinished;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> secondFinished;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span> <span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            printFirst.run();</span><br><span class="line">            firstFinished = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!firstFinished) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printSecond.run();</span><br><span class="line">            secondFinished = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!secondFinished) &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            printThird.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面牵涉到了几个 Java 并发体系的概念。对象锁和 syncronize、Object#Wait、Object#Notify。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;没错，我又开了个坑。这次的问题是 &lt;a href=&quot;https://leetcode-cn.com/problems/print-in-order/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;按顺序打印&lt;/a&gt;。大意就是有 one two three 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>「Linux 内核」系统调用</title>
    <link href="https://razertory.me/2020/04/12/linux-kernel-system-call/"/>
    <id>https://razertory.me/2020/04/12/linux-kernel-system-call/</id>
    <published>2020-04-12T05:50:04.000Z</published>
    <updated>2020-04-18T08:54:30.936Z</updated>
    
    <content type="html"><![CDATA[<p>内核内存空间在操作系统中是受保护的。通常情况下，一个普通程序执行在用户空间。当需要与内核通信的时候，比如写文件到磁盘，就需要进行<strong>系统调用</strong>。</p><p>有趣的是，内核原生提供的系统调用很少(参考<a href="http://asm.sourceforge.net/syscall.html" target="_blank" rel="noopener">List of Linux/i386 system calls</a>)。当我们需要系统调用的时候，实际上是在调用调用的上一层 API。这一层 API 封装了各种系统调用（通常就是操作系统内置的 C 库）。现阶段，这一层 API 的标准来自于 IEEE ，名为 POSIX（Portable Operating System Interface）。这么做的原因是 unix 倡导的 <em>提供机制，而不是提供策略</em>。意思是提供有限的，但可以很好组合的工具、方法，在此基础上实现各种功能。</p><p>例如，</p><p><code>get_pid()</code> 在内核中的被定义为 <code>sys_getpid()</code><br><code>bar()</code> 在内核中被定义为 <code>sys_bar()</code></p><p>一个用户空间的程序，要做系统调用，具体的过程为</p><ul><li>陷入内核</li><li>传递系统调用编号和参数</li><li>执行系统调用</li><li>将系统调用的返回值带给用户空间</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内核内存空间在操作系统中是受保护的。通常情况下，一个普通程序执行在用户空间。当需要与内核通信的时候，比如写文件到磁盘，就需要进行&lt;strong&gt;系统调用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有趣的是，内核原生提供的系统调用很少(参考&lt;a href=&quot;http://asm.so
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://razertory.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>「Linux 内核」中断</title>
    <link href="https://razertory.me/2020/04/12/linux-kernel-interrupt/"/>
    <id>https://razertory.me/2020/04/12/linux-kernel-interrupt/</id>
    <published>2020-04-12T05:50:04.000Z</published>
    <updated>2020-04-19T14:28:18.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中断信号"><a href="#中断信号" class="headerlink" title="中断信号"></a>中断信号</h3><p>中断机制，简单说就是键盘、鼠标、磁盘之类的硬件，在需要的时候向内核发信号的一种机制。比如我此刻正在用键盘打字，其实就是在发出电信号给一个名叫「中断控制器」的物理芯片中，再通过一个和处理器直连的管线给处理器。处理器接收到之后，监测到了是中断信号，就会中断当前的工作处理该信号进而告诉操作系统，让操作系统处理这个信号。不同的中断信号，有的着唯一的 IRQ 编号。比如时钟 IRQ 0，键盘 IRQ 1，有的是动态分配的，比如在 PCI 总线上的设备。</p><h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><p>操作系统处理中断的过程一般分成两个部分，命名为「上半部（top half）」和「下半部（bottom half）」。一般上半部(中断处理程序)有严格时限的操作，比方说快速应答。而有的可以延后执行的操作就交给了下半部。举个例子，操作系统处理网卡数据包的时候，会在上半部把网络数据拷贝到内存，下半部做数据处理的操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fly1gdzeyef51dj217m0kmq9a.jpg" alt="image.png" title>                </div>                <div class="image-caption">image.png</div>            </figure><h3 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h3><p><strong>时间敏感</strong>，<strong>硬件相关</strong>或者<strong>保证不能中断</strong>的任务，通常一定是在上半部，否则都在下半部。下半部的实现机制，在 linux 内核发展中经历了几个版本。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fly1gdzfdr63ytj212s0ak428.jpg" alt="tasklet 基于软中断实现" title>                </div>                <div class="image-caption">tasklet 基于软中断实现</div>            </figure><p>软中断是编译期间分配的，由 softirq_action 表示。定义在 <a href="https://github.com/torvalds/linux/blob/master/include/linux/interrupt.h" target="_blank" rel="noopener">linux/interrupt.h</a>。</p><p><a href="https://github.com/torvalds/linux/blob/master/kernel/softirq.c" target="_blank" rel="noopener">kernel/softirq.c</a> 里面定义了一个包含 32 个结构体的数组。每个结构体表示一个软中断，因此软中断最多有 32 个。不过目前这用到了 9 个。当软中断开始工作的时候，会执行一个名叫 <code>void softirq_handler(struct softirq_action *)</code> 的函数去标记注已经册的软中断。</p><p>等到合适的时候，该软中断就会执行，比如</p><ul><li>从硬件中断代码返回的时候  </li><li>在 ksoftirqd 内核线程中</li><li>在一些显式执行、显式检查软中断的程序中，比如网络系统中</li></ul><p>tasklet 源自软中断，提供了动态分配的特性，有着更广泛的应用场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;中断信号&quot;&gt;&lt;a href=&quot;#中断信号&quot; class=&quot;headerlink&quot; title=&quot;中断信号&quot;&gt;&lt;/a&gt;中断信号&lt;/h3&gt;&lt;p&gt;中断机制，简单说就是键盘、鼠标、磁盘之类的硬件，在需要的时候向内核发信号的一种机制。比如我此刻正在用键盘打字，其实就是在发出
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://razertory.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>「Linux 内核」进程管理</title>
    <link href="https://razertory.me/2020/04/11/linux-kernel-process/"/>
    <id>https://razertory.me/2020/04/11/linux-kernel-process/</id>
    <published>2020-04-11T10:15:42.000Z</published>
    <updated>2020-04-11T11:54:05.665Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>进程是处于执行期的程序以及相关资源的总称。比如打开的文件、挂起的信号、内核内部数据等等。在 linux 源码中，一个进程的相关信息维护在 task_struct <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L632" target="_blank" rel="noopener">task_struct</a>的结构体中。这里面包含了进程的状态(pid，运行状态)、相关资源、以及相关进程（子进程、父进程）信息。内核会维护一个双向链表，每个链表的节点指向对应的 task_struct。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul><li>TASK_RUNNING: 可执行的；等待执行的</li><li>TASK_INTERRUPTIBLE: 可中断的; 比如被阻塞、或者在 sleep</li><li>TASK_UNINTERRUPTIBLE: 不可中断的; 对外界的信号不做出响应</li><li>EXIT_ZOMBIE: 主动退出；还没有完全释放资源</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fgy1gdq0dnlo0cg20fw09b0sw.gif" alt="进程状态图" title>                </div>                <div class="image-caption">进程状态图</div>            </figure><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>在进程被 fork 出来之后 task_struct 会有自己的 pid 和父进程的 pid。但一些必要的系统资源并不会拷贝过来，而是当需要写入的时候再做(copy-on-write)。进程调用 exit() 结束, 部分资源会释放，同时调用 exit_notify() 向父进程发信号。若父进程及时响应，此时释放所有的资源；否则认为此时的这个进程是僵尸进程。同理，如果父进程先于子进程退出，子进程就会成为孤儿进程。内核会将这类进程归给 pid 为 1 的进程。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是一种特殊的进程（强调只是 linux）同一个进程的 N 个线程只是 N 个共享同一块资源的<br>task_struct。比如进程创建的时候会依赖 clone 方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>而线程的创建就是传递来一些参数来指明被共享的资源，这个设计现在看起来也是非常优雅的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h4&gt;&lt;p&gt;进程是处于执行期的程序以及相关资源的总称。比如打开的文件、挂起的信号、内核内部数据等等。在 linux 源码中，一个进程的相关信息维护在 t
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://razertory.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Scala 函数式编程设计</title>
    <link href="https://razertory.me/2020/02/20/functional-program-design-in-scala/"/>
    <id>https://razertory.me/2020/02/20/functional-program-design-in-scala/</id>
    <published>2020-02-20T15:53:05.000Z</published>
    <updated>2020-03-28T13:02:10.018Z</updated>
    
    <content type="html"><![CDATA[<p>在这个 2020 年初的特殊时期。</p><p>Scala 是一门现代化，多范式的 JVM 语言。</p><p>传送门（可能需要🚀)</p><ul><li><a href="https://www.coursera.org/learn/progfun2" target="_blank" rel="noopener">Functional Program Design in Scala on Coursera</a></li><li><a href="https://www.coursera.org/account/accomplishments/certificate/BP5FRUVSFPN8" target="_blank" rel="noopener">没什么用的 certificate</a></li></ul><hr><h2 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h2><h3 id="case-class-和模式匹配"><a href="#case-class-和模式匹配" class="headerlink" title="case class 和模式匹配"></a>case class 和模式匹配</h3><p>用 Scala 来表示 JSON 对象可以这样</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSON</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JSeq</span> (<span class="params">elems: <span class="type">List</span>[<span class="type">JSON</span>]</span>) <span class="keyword">extends</span> <span class="title">JSON</span>  <span class="title">//</span> <span class="title">JSON</span> <span class="title">的数组</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JObj</span> (<span class="params">bindings: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">JSON</span>]</span>) <span class="keyword">extends</span> <span class="title">JSON</span> <span class="title">//</span> <span class="title">JSON</span> <span class="title">对象</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JNum</span> (<span class="params">num: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">JSON</span> <span class="title">//</span> <span class="title">数字类型</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JStr</span> (<span class="params">str: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">JSON</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JBool</span>(<span class="params">b: <span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">JSON</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">JNull</span> <span class="keyword">extends</span> <span class="title">JSON</span> <span class="title">//</span> <span class="title">空</span></span></span><br></pre></td></tr></table></figure><p>所以，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"firstName"</span> : <span class="string">"John"</span>,</span><br><span class="line">    <span class="attr">"lastName"</span> : <span class="string">"Smith"</span>,</span><br><span class="line">    <span class="attr">"address"</span> : &#123;</span><br><span class="line">        <span class="attr">"streetAddress"</span> : <span class="string">"21 2 nd Street"</span>,</span><br><span class="line">        <span class="attr">"state"</span> : <span class="string">"NY"</span>,</span><br><span class="line">        <span class="attr">"postalCode"</span>: <span class="number">10021</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"phoneNumbers"</span>: [</span><br><span class="line">        &#123;<span class="attr">"type"</span> : <span class="string">"home"</span>,<span class="attr">"number "</span>: <span class="string">"212 555 -1234"</span>&#125; ,</span><br><span class="line">        &#123;<span class="attr">"type"</span> : <span class="string">"fax"</span>,<span class="attr">"number "</span>: <span class="string">"646 555 -4567"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以表示为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> data = <span class="type">JObj</span>(<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"firstName"</span> -&gt; <span class="type">JStr</span>(<span class="string">"John"</span>),</span><br><span class="line">    <span class="string">"lastName"</span> -&gt; <span class="type">JStr</span>(<span class="string">"Smith"</span>),</span><br><span class="line">    <span class="string">"address"</span> -&gt; <span class="type">JObj</span>(<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"streetAddress"</span> -&gt; <span class="type">JStr</span>(<span class="string">"21 2nd Street"</span>),</span><br><span class="line">    <span class="string">"state"</span> -&gt; <span class="type">JStr</span>(<span class="string">"NY"</span>),</span><br><span class="line">    <span class="string">"postalCode"</span> -&gt; <span class="type">JNum</span>(<span class="number">10021</span>)</span><br><span class="line">)),</span><br><span class="line"><span class="string">"phoneNumbers"</span> -&gt; <span class="type">JSeq</span>(<span class="type">List</span>(</span><br><span class="line">    <span class="type">JObj</span>(<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"type"</span> -&gt; <span class="type">JStr</span>(<span class="string">"home"</span>), <span class="string">"number"</span> -&gt; <span class="type">JStr</span>(<span class="string">"212 555-1234"</span>)</span><br><span class="line">)),</span><br><span class="line"><span class="type">JObj</span>(<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"type"</span> -&gt; <span class="type">JStr</span>(<span class="string">"fax"</span>), <span class="string">"number"</span> -&gt; <span class="type">JStr</span>(<span class="string">"646 555-4567"</span>)</span><br><span class="line">)) )) ))</span><br></pre></td></tr></table></figure><p>比如说我要实现一个打印 JSON 对象的方法，就可以</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span></span>(json: <span class="type">JSON</span>): <span class="type">String</span> = json <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSeq</span>(elems) =&gt;</span><br><span class="line">    <span class="string">"["</span> + (elems map show mkString <span class="string">", "</span>) + <span class="string">"]"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JObj</span>(bindings) =&gt;</span><br><span class="line">    <span class="keyword">val</span> assocs = bindings map &#123;</span><br><span class="line">        <span class="keyword">case</span> (key, value) =&gt; <span class="string">"\""</span> + key + <span class="string">"\": "</span> + show(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">"&#123;"</span> + (assocs mkString <span class="string">", "</span>) + <span class="string">"&#125;"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JNum</span>(num) =&gt; num.toString</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JStr</span>(str) =&gt; '\<span class="string">"' + str + '\"'</span></span><br><span class="line"><span class="string">    case JBool(b) =&gt; b.toString</span></span><br><span class="line"><span class="string">    case JNull =&gt; "</span><span class="string">null"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上述的 show(data) 就输出</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res1: <span class="type">String</span> = &#123;<span class="string">"firstName"</span>: <span class="string">"John"</span>, <span class="string">"lastName"</span>: <span class="string">"Smith"</span>, <span class="string">"address"</span>: &#123;<span class="string">"streetAddress"</span>: <span class="string">"21 2nd Street"</span>, <span class="string">"state"</span>: <span class="string">"NY"</span>, <span class="string">"postalCode"</span>: <span class="number">10021.0</span>&#125;, <span class="string">"phoneNumbers"</span>: [&#123;<span class="string">"type"</span>: <span class="string">"home"</span>, <span class="string">"number"</span>: <span class="string">"212 555-1234"</span>&#125;, &#123;<span class="string">"type"</span>: <span class="string">"fax"</span>, <span class="string">"number"</span>: <span class="string">"646 555-4567"</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>第 6 行代码里面 map 传入的函数是，我们知道，在这里 map 函数的签名是 <code>def map[B](f: (A) =&gt; B): List[B]</code><br>那么第六行的 <code>f</code> 就是 <code>case (key, value) =&gt; &quot;\&quot;&quot; + key + &quot;\&quot;: &quot; + show(value)</code>。 这个函数如果单独拎出来，其实就是</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f: (<span class="type">String</span>, <span class="type">JSON</span>) =&gt; <span class="type">String</span> = &#123; <span class="keyword">case</span> (key, value) =&gt; key + ”: ” + value &#125; <span class="comment">// 注意看 JObj 定义</span></span><br></pre></td></tr></table></figure><p>所以用 case class 最方便的地方在于<strong>模式匹配中的 decompose</strong></p><h3 id="函数即对象"><a href="#函数即对象" class="headerlink" title="函数即对象"></a>函数即对象</h3><p>任何情况下，函数 <code>A =&gt; B</code> 其实就是</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala.<span class="type">Function1</span>[<span class="type">A</span>, <span class="type">B</span>]</span><br></pre></td></tr></table></figure><p>的简写。</p><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><p>根据 Function1 的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">A</span>, +<span class="type">R</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">A</span>): <span class="type">R</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f1: <span class="type">Int</span> =&gt; <span class="type">Int</span> = (x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> f2 = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>) = x + <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>f1 和 f2 等价。</p><h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><p>对于偏函数 PartialFunction 定义为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PartialFunction</span>[-<span class="type">A</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">Function1</span>[-<span class="type">A</span>, +<span class="type">R</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">A</span>): <span class="type">R</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">A</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f1: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] = &#123; <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="string">"pong"</span> &#125;</span><br><span class="line"><span class="keyword">val</span> f2 = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">String</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="string">"pong"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">String</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f1 和 f2 等价。</p><p>ps: 以上，「等价」的意思是两个函数只要输入相同，输出一定相同。</p><h2 id="W2"><a href="#W2" class="headerlink" title="W2"></a>W2</h2><h3 id="LazyList"><a href="#LazyList" class="headerlink" title="LazyList"></a>LazyList</h3><p>下面代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  println(x + <span class="string">" "</span>)</span><br><span class="line">  x % <span class="number">11</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> v1 = (<span class="number">1</span> to <span class="number">100000</span>).filter(f)(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> v2 = (<span class="number">1</span> to <span class="number">100000</span>).to(<span class="type">LazyList</span>).filter(f)(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>v1 和 v2 等价。计算 v1 的时候会打印 <code>1 2 3...9999 100000</code>, 而计算 v2 的时候打印 <code>1 2 3 ... 21 22</code>。这是因为对于 v2，<code>(1 to 100000).to(LazyList)</code> 产生的是 <code>scala.collection.immutable.LazyList</code>。其中官方文档对其有个简单的描述</p><blockquote><p>This class implements an immutable linked list that evaluates elements in order and only when needed</p></blockquote><p>也就是当 LazyList 里面的元素被需要的时候，才会进行有序计算，并且计算会终止知道所需的元素计算结束。这也就是为什么会有上述的输出了。</p><h3 id="惰性求值-Lazy-Evaluation"><a href="#惰性求值-Lazy-Evaluation" class="headerlink" title="惰性求值 Lazy Evaluation"></a>惰性求值 Lazy Evaluation</h3><p>在 Scala 里面，Lazy 意味着两点</p><ul><li><strong>尽量延后求值计算</strong></li><li><strong>只计算一次</strong></li></ul><p>例如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">val</span> x = &#123; print(”x”); <span class="number">1</span> &#125;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> y = &#123; print(”y”); <span class="number">2</span> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">z</span> </span>= &#123; print(”z”); <span class="number">3</span> &#125;</span><br><span class="line">  z + y + x + z + y + x <span class="comment">// last line</span></span><br><span class="line">&#125;</span><br><span class="line">expr</span><br></pre></td></tr></table></figure><p>这样的输出为 <code>xzyz</code></p><h3 id="Infinite-Sequences"><a href="#Infinite-Sequences" class="headerlink" title="Infinite Sequences"></a>Infinite Sequences</h3><p>利用 LazyList 的特性，可以构造出无限序列。比如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">from</span></span>(n: <span class="type">Int</span>): <span class="type">LazyList</span>[<span class="type">Int</span>] = n #:: from(n + <span class="number">1</span>) <span class="comment">// 无限序列</span></span><br><span class="line">from: (n: <span class="type">Int</span>)<span class="type">LazyList</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> natures = from(<span class="number">0</span>) <span class="comment">// 自然数</span></span><br><span class="line">natures: <span class="type">LazyList</span>[<span class="type">Int</span>] = <span class="type">LazyList</span>(&lt;not computed&gt;)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> hundreds = natures.filter(_ % <span class="number">100</span> == <span class="number">0</span>)</span><br><span class="line">hundreds: scala.collection.immutable.<span class="type">LazyList</span>[<span class="type">Int</span>] = <span class="type">LazyList</span>(&lt;not computed&gt;)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> fourHundred = hundreds(<span class="number">4</span>) <span class="comment">// 计算</span></span><br><span class="line">fourHundred: <span class="type">Int</span> = <span class="number">400</span></span><br></pre></td></tr></table></figure><p><strong>埃拉托斯特尼筛法</strong></p><blockquote><p>埃拉托斯特尼筛法是列出所有小素数最有效的方法之一，其名字来自于古希腊数学家埃拉托斯特尼，并且被描述在另一位古希腊数学家尼科马库斯所著的《算术入门》中。-<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>用 LazyList 实现会非常简单，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>(n: <span class="type">Int</span>): <span class="type">LazyList</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  n #:: from(n + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sieve</span></span>(s: <span class="type">LazyList</span>[<span class="type">Int</span>]): <span class="type">LazyList</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  s.head #:: sieve(s.tail.filter(_ % s.head != <span class="number">0</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primeNumber</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    sieve(from(<span class="number">2</span>))(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> n = sieve(from(<span class="number">2</span>))(<span class="number">100</span>) <span class="comment">// 输出 547</span></span><br></pre></td></tr></table></figure><h3 id="题目：倒水问题"><a href="#题目：倒水问题" class="headerlink" title="题目：倒水问题"></a>题目：倒水问题</h3><p>给几个知道容量，但是没有刻度的杯子，有个可以取之不尽的水源用来给杯子装满水和将杯子的水全部倒出。我们需要做的就是盛出给定容量的水。我们能做的操作有三个</p><ul><li>empty 清空</li><li>fill 放满水</li><li>pour(a, b) 把 a 的水全部往 b 倒直至 b 杯满了或者 a 杯没水了</li></ul><p>现在需要找到取得容量为 N 的水时，需要的操作。</p><p>附：1. <a href="https://github.com/razertory/scala-code-lab/blob/master/src/main/scala/scalaschool/WaterPouring.scala" target="_blank" rel="noopener">Scala 完整代码</a> 2. <a href="https://www.youtube.com/watch?v=q6M_pco_5Vo" target="_blank" rel="noopener">python 解法</a></p><h2 id="W3"><a href="#W3" class="headerlink" title="W3"></a>W3</h2><blockquote><p>下面会用 Scala 进行加法器模拟。对于计算机中，两个数如何相加，可以提前阅读 <a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B3%95%E5%99%A8" target="_blank" rel="noopener">维基百科-加法器</a>，最好能够做一下 <a href="/2019/11/11/add-by-bit/">位运算实现加法</a>。</p></blockquote><p>通过以上内容，我们需要知道的最重要的点在于：两个一位二进制数相加，将会产生两个输出，其中一个是当前位相加的值 S，另一个是相加后的进位信息 C。其中 S 可以用<em>异或门</em>，进位可以用<em>与门</em>。两个半加器用<em>或</em>门组合为一个全加器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fgy1gc6mm6fcccj21fo0rgh3a.jpg" alt="异或的操作通过三种门的组合实现" title>                </div>                <div class="image-caption">异或的操作通过三种门的组合实现</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fgy1gc6mmvhps1j20tq0ja10b.jpg" alt="两个用与门组合的半加器构成一个全加器" title>                </div>                <div class="image-caption">两个用与门组合的半加器构成一个全加器</div>            </figure><p>根据上图，我们至少需要实现的是</p><ul><li><p>电线：用来传导信号，信号可以用 boolean 类型表示 0 和 1</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wire</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> sigVal = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getSignal</span></span>: <span class="type">Boolean</span> = sigVal</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setSignal</span></span>(s: <span class="type">Boolean</span>): <span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">if</span> (s != sigVal) &#123;</span><br><span class="line">        sigVal = s</span><br><span class="line">        actions foreach(_())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与门：输入两个电信号，输出 &amp; 对应的信号</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">andGate</span></span>(in1: <span class="type">Wire</span>, in2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = ???</span><br></pre></td></tr></table></figure><ul><li>或门：输入两个电信号，输出 | 对应的信号</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orGate</span></span>(in1: <span class="type">Wire</span>, in2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = ???</span><br></pre></td></tr></table></figure><ul><li>逆变器：输入电信号，输出 ! 对应的信号</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverter</span></span>(in: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = ???</span><br></pre></td></tr></table></figure><p>在此基础上，实现出半加器和全加器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">halfAdder</span></span>(a: <span class="type">Wire</span>, b: <span class="type">Wire</span>, s: <span class="type">Wire</span>, c: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> d = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  <span class="keyword">val</span> e = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  orGate(a, b, d)</span><br><span class="line">  andGate(a, b, c)</span><br><span class="line">  inverter(c, e)</span><br><span class="line">  andGate(d, e, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullAdder</span></span>(a: <span class="type">Wire</span>, b: <span class="type">Wire</span>, cin: <span class="type">Wire</span>, sum: <span class="type">Wire</span>, cout: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> s = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  <span class="keyword">val</span> c1 = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  <span class="keyword">val</span> c2 = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  halfAdder(b, cin, s, c1)</span><br><span class="line">  halfAdder(a, s, sum, c2)</span><br><span class="line">  orGate(c1, c2, cout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了全加器后。加入模拟信号的输入输出即可，完整代码 <a href="https://github.com/razertory/scala-code-lab/blob/master/src/main/scala/scalaschool/DigitalCircuitSimulator.scala" target="_blank" rel="noopener">模拟加法器</a></p><h2 id="W4"><a href="#W4" class="headerlink" title="W4"></a>W4</h2><h3 id="Functional-Reactive-Programming-FRP"><a href="#Functional-Reactive-Programming-FRP" class="headerlink" title="Functional Reactive Programming (FRP)"></a>Functional Reactive Programming (FRP)</h3><p>在 MVC 模型中，FRP 可以让 model 在产生变化的同时 view 自动变化。这样的模型一般也就是 pub-sub 模型或者叫观察者模型 (observers)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subscriber1   subscribe     ___________</span><br><span class="line">Subscriber2  ------------&gt; |          |</span><br><span class="line">Subscriber3                |Publisher |</span><br><span class="line">Subscriber4  &lt;------------ |          |</span><br><span class="line">Subscriber5    publish     |__________|</span><br></pre></td></tr></table></figure><p>通用的说比如 <code>a = f(b)</code> 里面。当 b 在发生变化的时候 a 也会跟着变。实现这一点，<br>可以把「变化」归化为「event」，而自动检查这些「event」的东西叫做 Signal。在 Scala 里面通常把这样的 Signal 实现为一个类型，通过 apply() 给其赋值。比如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="type">Signal</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> v = s() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>同时，为了给 Signal 再次赋值，可以扩展新增一个 update 方法。比如 <code>s.update(5)</code>，顺带可以写成 <code>s() = 5</code>。这样的话，实现一个扩展了 Signal 名为 <code>Var</code> 的类型，让其拥有 <code>update</code> 方法。</p><p>在这样的条件下，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">val</span> num = <span class="type">Var</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> twice = <span class="type">Signal</span>(num() * <span class="number">2</span>)</span><br><span class="line">num() = <span class="number">2</span></span><br><span class="line"><span class="comment">// (2)</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="type">Var</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> twice = <span class="type">Signal</span>(num() * <span class="number">2</span>)</span><br><span class="line">num = <span class="type">Var</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>(1) 里面的 twice 变为 4，（2）里面的 twice 还是 2。上述体现的 FRP 里面，num 是 <em>publisher</em>，twice 是 <em>subscriber</em>。num 产生了 event，twice 接受这样的 event。并且所有的变量本身都是 <em>immutable</em>。</p><h3 id="实现-FRP"><a href="#实现-FRP" class="headerlink" title="实现 FRP"></a>实现 FRP</h3><h4 id="Var-和-Signal"><a href="#Var-和-Signal" class="headerlink" title="Var 和 Signal"></a>Var 和 Signal</h4><p>我们知道 Signal 和 Var 应该是这样</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>[<span class="type">T</span>](<span class="params">expr: =&gt; <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">T</span> = ???</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Signal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](expr: =&gt; <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">Signal</span>(expr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Var</span>[<span class="type">T</span>](<span class="params">expr: =&gt; <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Signal</span>[<span class="type">T</span>](<span class="params">expr</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(expr: =&gt; <span class="type">T</span>): <span class="type">Unit</span> = ???</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Var</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](expr: =&gt; <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">Var</span>(expr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="维护订阅关系"><a href="#维护订阅关系" class="headerlink" title="维护订阅关系"></a>维护订阅关系</h3><p>有了这些方法，就可以做到赋值和再次赋值。还需要的是，当一个 publisher 产生了 event 的时候，如何自动通知到对应的 subscriber，并且让其重新计算（re-evaluate）。</p><p>例如，s 是 Var 类型，并且进入到了表达式 expr 里，形如 <code>expr s</code>，那么当表达式 <code>expr s</code>，作为参数传递给了某个 Signal 形如 <code>val t = Signal(expr s)</code> 的时候。就需要给 s 维护一个 subscriber。同理，当有多个 subscribers 的时候就给 s 维护一个 subscriber 的集合。比如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val set = Set()</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="type">Var</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发的条件就是 class Var 的 apply 方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发：set += Signal(num() * 2)</span></span><br><span class="line"><span class="keyword">val</span> double = <span class="type">Signal</span>(num() * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发：set += Signal(num() * 3)</span></span><br><span class="line"><span class="keyword">val</span> tiple = <span class="type">Signal</span>(num() * <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>触发的条件达到了，可是如何把 <code>Signal(num() * 3)</code> 这样的对象传递给 num 的 set ？</p><p>这个时候就需要在 Object Signal 里面新增一块用于维护方法调用的数据结构，没做就是 stack</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Signal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> caller = <span class="keyword">new</span> <span class="type">StackableVariable</span>[<span class="type">Signal</span>[_]](<span class="type">NoSignal</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](expr: =&gt; <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">Signal</span>(expr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StackableVariable 在当前的上下文中多个 Signal/Object 会共享。当调用 class Signal 的 apply() 方法的时候就去这里面找到当前的调用方。</p><h3 id="维护调用栈"><a href="#维护调用栈" class="headerlink" title="维护调用栈"></a>维护调用栈</h3><p>调用栈里面存放有序的 Signal。例如，有下面测试代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"multi subscribers"</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> publisher = <span class="type">Var</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">val</span> subscriber1 = <span class="type">Signal</span>(publisher() * <span class="number">20</span>) <span class="comment">// 注意 scala 的 call-by-name 和 call-by-value。这里传递的是表达式</span></span><br><span class="line">  <span class="keyword">val</span> subscriber2 = <span class="type">Signal</span>(publisher() * <span class="number">30</span>)</span><br><span class="line">  <span class="keyword">val</span> subscriber3 = <span class="type">Signal</span>(publisher() * <span class="number">40</span>)</span><br><span class="line">  assert(subscriber1() == <span class="number">20</span>)</span><br><span class="line">  assert(subscriber2() == <span class="number">30</span>)</span><br><span class="line">  assert(subscriber3() == <span class="number">40</span>)</span><br><span class="line">  publisher() = <span class="number">2</span></span><br><span class="line">  assert(subscriber1() == <span class="number">40</span>)</span><br><span class="line">  assert(subscriber2() == <span class="number">60</span>)</span><br><span class="line">  assert(subscriber3() == <span class="number">80</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三行开始，包含表达式的 Signal 进入调用栈，并不断被带入 subscriber 的集合。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackableVariable</span>[<span class="type">T</span>](<span class="params">init: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> values: <span class="type">List</span>[<span class="type">T</span>] = <span class="type">List</span>(init)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">T</span> = values.head</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withValue</span></span>[<span class="type">R</span>](newValue: <span class="type">T</span>)(op: =&gt; <span class="type">R</span>): <span class="type">R</span> = &#123;</span><br><span class="line">    values = newValue :: values</span><br><span class="line">    <span class="keyword">try</span> op <span class="keyword">finally</span> values = values.tail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/razertory/scala-code-lab/blob/master/src/main/scala/scalaschool/SubPub.scala" target="_blank" rel="noopener">完整代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这个 2020 年初的特殊时期。&lt;/p&gt;
&lt;p&gt;Scala 是一门现代化，多范式的 JVM 语言。&lt;/p&gt;
&lt;p&gt;传送门（可能需要🚀)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.coursera.org/learn/progfun2&quot; targ
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LRU 缓存</title>
    <link href="https://razertory.me/2020/02/16/lru-cache/"/>
    <id>https://razertory.me/2020/02/16/lru-cache/</id>
    <published>2020-02-16T09:39:04.000Z</published>
    <updated>2020-03-28T13:02:10.018Z</updated>
    
    <content type="html"><![CDATA[<p>LRU 的全称是 Least recently used，是缓存替换策略的一种。电脑存储器空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。此原则即所谓缓存替换策略。<br><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">传送门</a></p><hr><p>实现 LRU 缓存需要用到 kv 类型和线型的数据结构，用来做到 O(1) 的查找效率和实现淘汰机制。我们可以用 HashMap 和一个双向链表。其中用双向链表的好处是：当要删除的节点为 node 的时候，通过 <code>node.pre</code> 和 <code>node.next</code> 可以快速找到前后节点，从而在链表中去掉这个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    LinkNode prev;</span><br><span class="line">    LinkNode next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增的 node 只作为 head</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(LinkNode node)</span> </span>&#123;</span><br><span class="line">    node.prev = head;</span><br><span class="line">    node.next = head.next;</span><br><span class="line"></span><br><span class="line">    head.next.prev = node;</span><br><span class="line">    head.next = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 prev 和 next 快速删除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(LinkNode node)</span></span>&#123;</span><br><span class="line">    LinkNode prev = node.prev;</span><br><span class="line">    LinkNode next = node.next;</span><br><span class="line"></span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先删除，后新增从而指向头部</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(LinkNode node)</span></span>&#123;</span><br><span class="line">    removeNode(node);</span><br><span class="line">    addNode(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 淘汰末尾</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> LinkNode <span class="title">popTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkNode res = tail.prev;</span><br><span class="line">    removeNode(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;Integer, LinkNode&gt; cache =</span><br><span class="line">          <span class="keyword">new</span> HashMap&lt;Integer, LinkNode&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">  <span class="keyword">private</span> LinkNode head, tail;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">    head = <span class="keyword">new</span> LinkNode();</span><br><span class="line">    tail = <span class="keyword">new</span> LinkNode();</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    LinkNode node = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    moveToHead(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    LinkNode node = cache.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      LinkNode newNode = <span class="keyword">new</span> LinkNode();</span><br><span class="line">      newNode.key = key;</span><br><span class="line">      newNode.value = value;</span><br><span class="line"></span><br><span class="line">      cache.put(key, newNode);</span><br><span class="line">      addNode(newNode);</span><br><span class="line"></span><br><span class="line">      ++size;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(size &gt; capacity) &#123;</span><br><span class="line">        LinkNode tail = popTail();</span><br><span class="line">        cache.remove(tail.key);</span><br><span class="line">        --size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = value;</span><br><span class="line">      moveToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种更为优雅的实现是让这个双向链表成环状，初始化为 value 都为 -1，大小为 capacity。每当有 get 和 put 操作的时候就调整环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key, val;</span><br><span class="line">        Node next, pre;</span><br><span class="line">        Node(<span class="keyword">int</span> key, <span class="keyword">int</span> val, Node pre, Node next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.pre = pre;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == head) &#123;</span><br><span class="line">            head = head.pre;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.pre.next = cur.next;</span><br><span class="line">        cur.next.pre = cur.pre;</span><br><span class="line"></span><br><span class="line">        cur.next = head.next;</span><br><span class="line">        cur.next.pre = cur;</span><br><span class="line">        head.next = cur;</span><br><span class="line">        cur.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>, cur, <span class="keyword">null</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head;</span><br><span class="line">        head.pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            node.val = val;</span><br><span class="line">            move2Head(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != -<span class="number">1</span>) map.remove(head.key);</span><br><span class="line">            head.key = key;</span><br><span class="line">            head.val = val;</span><br><span class="line">            map.put(key, head);</span><br><span class="line">            head = head.pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Java 中的 LinkedHashMap 可以直接实现 LRU 缓存。:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LRU 的全称是 Least recently used，是缓存替换策略的一种。电脑存储器空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。此原则即所谓缓存替换策略。&lt;br&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编辑距离</title>
    <link href="https://razertory.me/2020/01/11/edit-distance/"/>
    <id>https://razertory.me/2020/01/11/edit-distance/</id>
    <published>2020-01-11T03:35:32.000Z</published>
    <updated>2020-03-28T13:02:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>给出两个单词 word1 和 word2，找出把 word1 编辑成 word2 的最短编辑距离。给出的可用编辑操作有：</p><ol><li>插入一个字符 insert</li><li>删除一个字符 delete</li><li>更新一个字符 update</li></ol><blockquote><p>编辑距离是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。编辑距离可以用在自然语言处理中，例如拼写检查可以根据一个拼错的字和其他正确的字的编辑距离，判断哪一个（或哪几个）是比较可能的字。DNA也可以视为用A、C、G和T组成的字符串，因此编辑距离也用在生物信息学中，判断二个DNA的类似程度。Unix 下的 diff 及 patch 即是利用编辑距离来进行文本编辑对比的例子。</p></blockquote><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">传送门</a></h2><p>对于 “a”, “”, 执行步骤 1<br>对于 “”, “a”, 执行步骤 2<br>对于 “a”, “b”, 执行步骤 3</p><p>假设字符串串 word1 和 word2 的最小编辑距离是 <code>d[i][j]</code> (i 和 j 代表 word1 和 word2 的长度 - 1)，当我们给 word1 和 word2 都 append 一个相同的字符的时候，这个编辑距离不变。因此可以认为，此时的 <code>d[i+1][j+1] == d[i][j]</code>。当 append 的字符不同的的时候。就是找到之前的最小编辑距离 + 1，这个之前的最小编辑距离可能是 <code>d[i][j]</code>、<code>d[i][j+1]</code>、或者 <code>d[i+1][j]</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fgy1gasiec3bhgj204q0710sl.jpg" alt="Edit-Distance.png" title>                </div>                <div class="image-caption">Edit-Distance.png</div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = word1.length() + <span class="number">1</span>, n = word2.length() + <span class="number">1</span>; <span class="comment">//多的一行留给空字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            d[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            d[<span class="number">0</span>][j] = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    d[i][j] = d[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d[i][j] = min(d[i-<span class="number">1</span>][j-<span class="number">1</span>], d[i][j-<span class="number">1</span>], d[i-<span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出两个单词 word1 和 word2，找出把 word1 编辑成 word2 的最短编辑距离。给出的可用编辑操作有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入一个字符 insert&lt;/li&gt;
&lt;li&gt;删除一个字符 delete&lt;/li&gt;
&lt;li&gt;更新一个字符 update&lt;/li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二维数组中和最小路径</title>
    <link href="https://razertory.me/2020/01/11/minimum-path-sum/"/>
    <id>https://razertory.me/2020/01/11/minimum-path-sum/</id>
    <published>2020-01-11T02:38:44.000Z</published>
    <updated>2020-03-28T13:02:10.017Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 m * n 大的非负组整数组成的二维数组中，找到一条从 left-top 到 right-bottom 的和最小的路径。输出这个路径的值。<a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">传送门</a></p><hr><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在这样一个矩阵中，从 <code>m[0][0]</code> 到 <code>m[2][2]</code> 的最短路径，可以看作是 <code>m[0][0]</code> 到 <code>m[1][2]</code> 的最短路径 (1-&gt;3-&gt;1-&gt;1) 以及 <code>m[2][1]</code> 的最短路径中取到的最小值 (1-&gt;1-&gt;4-&gt;2) 加上 <code>m[2][2]</code> 取到的最小值 1-&gt;3-&gt;1-&gt;1-&gt;1。因此可以得到关系式 </p><p><code>dp[m][n] = min(dp[m-1][n], dp[m][n-1]) + g[m][n]</code></p><p>利用这个关系式，处理好 m，n 为 0 的边界情况即可得出最短路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[m][n] = min(dp[m-1][n], dp[m][n-1]) + g[m][n] </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span> || g[<span class="number">0</span>] == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = g.length, w = g[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[h][w];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] + g[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + g[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + g[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[h-<span class="number">1</span>][w-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个 m * n 大的非负组整数组成的二维数组中，找到一条从 left-top 到 right-bottom 的和最小的路径。输出这个路径的值。&lt;a href=&quot;https://leetcode.com/problems/minimum-path-sum/&quot; target
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="https://razertory.me/2020/01/11/longest-palindromic-substring/"/>
    <id>https://razertory.me/2020/01/11/longest-palindromic-substring/</id>
    <published>2020-01-11T02:00:36.000Z</published>
    <updated>2020-03-28T13:02:10.017Z</updated>
    
    <content type="html"><![CDATA[<p>给一个字符串 s，找到其中最长的回文串。<a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">传送门</a></p><hr><p>回文串有两种模式，一种是 aabb 类型，另一种是 aacbb 类型。当我们对一个字符串做是否是回文的时候可以实现一个 expand 函数用作判断<code>int expand(String s, int lelf, int right)</code> 当 s[left] == s[right] 且 left 和 right 没有到达字符串边界的时候计算长度即 <code>right - left + 1</code>。</p><p>实现了 expand 之后，对于任意字符串可以确认：</p><ol><li>字符串长度为 1 的时候，本身就是回文串</li><li>字符串长度为 2 的时候，判断两个字符是否相等，相等说明本身是，否则和 1 一致</li><li>字符串长度为 n 的时候，在对字符串进行从左到右扫描找到最大值 <code>max (expand(s, i, i), expand(s, i, i + 1))</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expand(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expand(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">                start = i - (len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + max);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给一个字符串 s，找到其中最长的回文串。&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>抢劫房子</title>
    <link href="https://razertory.me/2020/01/11/house-robber/"/>
    <id>https://razertory.me/2020/01/11/house-robber/</id>
    <published>2020-01-11T01:33:19.000Z</published>
    <updated>2020-03-28T13:02:10.017Z</updated>
    
    <content type="html"><![CDATA[<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">传送门</a></p><hr><p>假设房子定义为 <code>house[i]</code></p><p>房屋数量是 1 的时候，小偷只能偷这一家 <code>house[0]</code>。</p><p>房屋数量是 2 的时候，小偷从现有的选一个多的，也就是 <code>max(house[0], house[1])</code></p><p>房屋数量是 3 的时候，小偷的选择为 <code>max(house[0] + house[2], house[1])</code></p><p>如果我们知道房屋数量为 i - 1 的时候，小偷的最佳选择是 <code>d[i-1]</code>，那么当再增加一个房屋，即房屋数量为 i 的时候。依据题意可以推导出</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[i] = max(house[i] + d[i-<span class="number">2</span>], d[i-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>翻译成代码就是 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) d[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) d[i] = Math.max(nums[i], nums[i-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> d[i] = Math.max(d[i-<span class="number">2</span>] + nums[i], d[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。&lt;br&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>买卖股票的最大利润</title>
    <link href="https://razertory.me/2020/01/09/max-stock-profit/"/>
    <id>https://razertory.me/2020/01/09/max-stock-profit/</id>
    <published>2020-01-09T05:02:03.000Z</published>
    <updated>2020-03-28T13:02:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖 一次 该股票可能获得的利润是多少？</p><p>例如一只股票在某些时间节点的价格为 [9, 11, 8, 5, 7, 12, 16, 14]。</p><p>如果我们能在价格为 5 的时候买入并在价格为 16 时卖出，则能收获最大的利润 11。<br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">传送门</a></p><hr><p>股票最大利润，其实就是个从头到尾一直更新最大利润。最大利润 = Math.max(前面的最大利润，当前股票价格 - 前面最低价格)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>], maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, nums[i]);</span><br><span class="line">        maxProfit = Math.max(maxProfit, nums[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖 一次 该股票可能获得的利润是多少？&lt;/p&gt;
&lt;p&gt;例如一只股票在某些时间节点的价格为 [9, 11, 8, 5, 7, 12, 16, 14]。&lt;/p&gt;
&lt;p&gt;如果我们能在价格为 5 的时候买入并在价格为 16 时卖
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020 新年快乐</title>
    <link href="https://razertory.me/2020/01/01/happy-new-year-2020/"/>
    <id>https://razertory.me/2020/01/01/happy-new-year-2020/</id>
    <published>2020-01-01T04:25:41.000Z</published>
    <updated>2020-03-28T13:02:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>现在是 2020 年的一月一日，和普通放假的日常一样：1. KFC，2.电脑， 3.看书/编程。和之前不一样的是，咖啡点的是加冰的美式。回想起过去的一年，不在办公室的时候，我通常也会去找一个地方学习，常做的事情有</p><ul><li>刷课。MIT 6.824、SICP 那种</li><li>刷 OJ。通常是 Leetcode 或者 codewars，其中在 leetcode 上打了一段时间的周赛</li><li>看书。通常都是计算机相关的书籍，最近看的是 FP 相关</li><li>写博客。和现在一样</li></ul><p>这些事情都是我换个人喜欢做的，但是对外却有优先级。比如说如果我最近要参加面试，我可能会花更多的时间在刷 OJ；如果我最近要用一门新语言/框架，我可能会选择看书；如果我最近时间比较充裕且没有外部的需求，那么我会像现在一样写博客或者用一段连续且足够长的时间来刷课程。</p><p>这么做既满足了自己的喜好，也能够根据外部的状态及调整。</p><p>随着时间的推移，我越来越觉得自己即将成为那种很标准的「职场码农」。快速完成外部的需求，给团队带来价值，快速学习一门新技术，快速补偿技术债。但是我自己也不得不承认，因为这种策略，我到目前没有那种能做到 top 的事情。首先解释一下做到 top：比如说刷 OJ，我可以通过周赛或者自己的积分排名来判断，或者我可以去给某个知名开源的框架做贡献，通过 contributors 排名来看自己做的程度。做到 top 有时候不仅仅是因为自己多多少少有「追名逐利」的情结，更因为我坚持认为，如果喜欢做一件事情，肯定有把事情做好的意愿，那么只要不断坚持做自然就会做到 top。</p><p>前段时间的一个周末，我去了一家摊饼店，拍下了一行字</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/mw690/a67b702fgy1gagzjtfpp5j20u01407fd.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果说，一个人可以一辈子专注于一件事情上，并且不会被别的事情所干扰或者诱惑应该是非常值得羡慕的。可是如果用资本家的眼光去看待这个，肯定会让人觉得这个人只知道打工(这里不把打工做贬义)。我记得在「泰囧」电影里面有个对白</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/mw690/a67b702fgy1gah030l1rhj20rs0doq4n.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/mw690/a67b702fgy1gah03e89o2j20rt0dt40p.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>资本家热爱「挣钱」本身这件事情，所以会用经营、扩张的眼光去看待做葱油饼。葱油饼小哥说秘方就是要自己亲自做，新鲜出炉，这是热爱做葱油饼人的眼光。不过这个世界就是需要这两种人。</p><p>如果把「做葱油饼」换成「写代码」，这个对白产生的效果应该是类似的。</p><p>我想说不论是为了更高的薪水不断学习，还是因为热爱编程本身不断学习，这两者应该是都被认可的。在现实世界中，我认为这两种动机应该是都存在的，或者说人本身就是这样的，既希望做的事情是自己喜欢的，也希望做的事情能给自己带来更多收入。</p><p>2020年，我们是野性和文明共存的。</p><p>新年快乐！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是 2020 年的一月一日，和普通放假的日常一样：1. KFC，2.电脑， 3.看书/编程。和之前不一样的是，咖啡点的是加冰的美式。回想起过去的一年，不在办公室的时候，我通常也会去找一个地方学习，常做的事情有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷课。MIT 6.824、SICP
      
    
    </summary>
    
    
      <category term="思考" scheme="https://razertory.me/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>有序数组转化为平衡二叉搜索树（BST）</title>
    <link href="https://razertory.me/2019/12/12/sorted-arr-to-bst/"/>
    <id>https://razertory.me/2019/12/12/sorted-arr-to-bst/</id>
    <published>2019-12-12T13:41:57.000Z</published>
    <updated>2020-03-28T13:02:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个有序数组，数组元素升序排列，试将该数组转换为一棵平衡二叉搜索树（Balanced Binary Search Tree）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">convertToBST</span><span class="params">(ArrayList&lt;Integer&gt; arr)</span></span></span><br></pre></td></tr></table></figure><p>根据 BST 的定义 <em>二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索,插入,删除的复杂度等于树高，O(log(n)).</em> 可以对其进行反中序的遍历。也就是 中-左-右 的一个逆向过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">convertToBST</span><span class="params">(ArrayList&lt;Integer&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> convert(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode <span class="title">convert</span><span class="params">(ArrayList&lt;Integer&gt; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">    node.left = convert(arr, start, mid - <span class="number">1</span>);</span><br><span class="line">    node.right = convert(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个有序数组，数组元素升序排列，试将该数组转换为一棵平衡二叉搜索树（Balanced Binary Search Tree）。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高级类型</title>
    <link href="https://razertory.me/2019/12/01/scala-school-advanced-types/"/>
    <id>https://razertory.me/2019/12/01/scala-school-advanced-types/</id>
    <published>2019-12-01T03:20:54.000Z</published>
    <updated>2020-05-04T07:02:15.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="视界（View-Bound-“类型类”）"><a href="#视界（View-Bound-“类型类”）" class="headerlink" title="视界（View Bound “类型类”）"></a>视界（View Bound “类型类”）</h3><p>有时候，你并不需要指定一个类型是等/子/超于另一个类，你可以通过转换这个类来伪装这种关联关系。一个视界指定一个类型可以被“看作是”另一个类型。这对对象的只读操作是很有用的。</p><p>隐式 (<code>implicit</code>) 函数允许类型自动转换。更确切地说，如果隐式函数有助于满足类型推断时，隐式函数可以按需地应用。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToInt</span></span>(x: <span class="type">String</span>) = x.toInt</span><br><span class="line">strToInt: (x: <span class="type">String</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="string">"123"</span></span><br><span class="line">res0: java.lang.<span class="type">String</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> y: <span class="type">Int</span> = <span class="string">"123"</span></span><br><span class="line">y: <span class="type">Int</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">scala&gt; math.max(<span class="string">"123"</span>, <span class="number">111</span>)</span><br><span class="line">res1: <span class="type">Int</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure><p>视界，就像类型边界，要求存在一个能够将某类型转换为指定类型的函数。你可以使用 <code>&lt;%</code> 指定类型限制，例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>[<span class="type">A</span> &lt;% <span class="type">Int</span>] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">addIt</span></span>(x: <span class="type">A</span>) = <span class="number">123</span> + x &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class"><span class="title">这是说</span> <span class="title">A</span> <span class="title">必须“可被视作”</span> <span class="title">Int</span> <span class="title">。让我们试试。</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> (<span class="params">new <span class="type">Container</span>[<span class="type">String</span>]</span>).<span class="title">addIt</span>(<span class="params">"123"</span>)</span></span><br><span class="line"><span class="class"><span class="title">res11</span></span>: <span class="type">Int</span> = <span class="number">246</span></span><br><span class="line"></span><br><span class="line">scala&gt; (<span class="keyword">new</span> <span class="type">Container</span>[<span class="type">Int</span>]).addIt(<span class="number">123</span>) </span><br><span class="line">res12: <span class="type">Int</span> = <span class="number">246</span></span><br><span class="line"></span><br><span class="line">scala&gt; (<span class="keyword">new</span> <span class="type">Container</span>[<span class="type">Float</span>]).addIt(<span class="number">123.2</span>F)</span><br><span class="line">&lt;console&gt;:<span class="number">8</span>: error: could not find <span class="keyword">implicit</span> value <span class="keyword">for</span> evidence parameter of <span class="class"><span class="keyword">type</span> (<span class="params"><span class="type">Float</span></span>) <span class="title">=&gt;</span> <span class="title">Int</span></span></span><br><span class="line"><span class="class">       (<span class="params">new <span class="type">Container</span>[<span class="type">Float</span>]</span>).<span class="title">addIt</span>(<span class="params">123.2</span>)</span></span><br><span class="line"><span class="class">        <span class="title">^</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意，新版本的 Scala 可能会提示：  view bounds are deprecated; use an implicit parameter instead.</p></blockquote><h3 id="其他类型限制"><a href="#其他类型限制" class="headerlink" title="其他类型限制"></a>其他类型限制</h3><p>方法可以通过隐式参数执行更复杂的类型限制。例如，List 支持对数字内容执行 sum，但对其他内容却不行。可是 Scala 的数字类型并不都共享一个超类，所以我们不能使用 <code>T &lt;: Number</code>。相反，要使之能工作，Scala 的 math 库对适当的类型 T 定义了一个隐含的 <code>Numeric[T]</code>。 然后在 List 定义中使用它：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">implicit</span> num: <span class="type">Numeric</span>[<span class="type">B</span>]): <span class="type">B</span></span><br></pre></td></tr></table></figure><p>如果你调用 List(1,2).sum()，你并不需要传入一个 num 参数；它是隐式设置的。但如果你调用 List(“whoop”).sum()，它会抱怨无法设置 num。</p><p>在没有设定陌生的对象为 Numeric 的时候，方法可能会要求某种特定类型的“证据”。这时可以使用以下<code>类型-关系运算符</code>：</p><ul><li>A <code>=:=</code> B    A 必须和 B 相等</li><li>A <code>&lt;:&lt;</code> B    A 必须是 B 的子类</li><li>A <code>&lt;%&lt;</code> B    A 必须可以被看做是 B</li></ul><p>（如果你在尝试使用 <code>&lt;:&lt;</code> 或者 <code>&lt;%&lt;</code> 的时候出错了，那请注意这些符号在 Scala 2.10 中被移除了。Scala School 里的例子仅能在 Scala 2.9.x 下正常工作。你可以使用新版本的 Scala，但可能会遇到错误。）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>[<span class="type">A</span>](<span class="params">value: <span class="type">A</span></span>) </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">addIt</span></span>(<span class="keyword">implicit</span> evidence: <span class="type">A</span> =:= <span class="type">Int</span>) = <span class="number">123</span> + value &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> (<span class="params">new <span class="type">Container</span>(123</span>)).<span class="title">addIt</span></span></span><br><span class="line"><span class="class"><span class="title">res11</span></span>: <span class="type">Int</span> = <span class="number">246</span></span><br><span class="line"></span><br><span class="line">scala&gt; (<span class="keyword">new</span> <span class="type">Container</span>(<span class="string">"123"</span>)).addIt</span><br><span class="line">&lt;console&gt;:<span class="number">10</span>: error: could not find <span class="keyword">implicit</span> value <span class="keyword">for</span> parameter evidence: =:=[java.lang.<span class="type">String</span>,<span class="type">Int</span>]</span><br></pre></td></tr></table></figure><p>类似地，根据之前的隐式转换，我们可以将约束放松为可视性：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Container</span>[<span class="type">A</span>](<span class="params">value: <span class="type">A</span></span>) </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">addIt</span></span>(<span class="keyword">implicit</span> evidence: <span class="type">A</span> &lt;%&lt; <span class="type">Int</span>) = <span class="number">123</span> + value &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Container</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> (<span class="params">new <span class="type">Container</span>("123"</span>)).<span class="title">addIt</span></span></span><br><span class="line"><span class="class"><span class="title">res15</span></span>: <span class="type">Int</span> = <span class="number">246</span></span><br></pre></td></tr></table></figure><p>使用视图 (View) 进行泛型编程<br>在 Scala 标准库中，视图主要用于实现集合的通用函数。例如 <code>min</code> 函数（在 <code>Seq[]</code> 上）就使用了这种技术：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">implicit</span> cmp: <span class="type">Ordering</span>[<span class="type">B</span>]): <span class="type">A</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEmpty)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span>(<span class="string">"empty.min"</span>)</span><br><span class="line"></span><br><span class="line">  reduceLeft((x, y) =&gt; <span class="keyword">if</span> (cmp.lteq(x, y)) x <span class="keyword">else</span> y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要优点是：</p><p>集合中的元素不必实现 Ordered trait，但 Ordered 的使用仍然可以执行静态类型检查。<br>无需任何额外的库支持，你也可以定义自己的排序：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).min</span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).min(<span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">Int</span>] &#123; <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>) = b compare a &#125;)</span><br><span class="line">res3: <span class="type">Int</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>作为旁注，标准库中有视图来将 Ordered 转换为 <code>Ordering</code>（反之亦然）。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">LowPriorityOrderingImplicits</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">ordered</span></span>[<span class="type">A</span> &lt;: <span class="type">Ordered</span>[<span class="type">A</span>]]: <span class="type">Ordering</span>[<span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Ordering</span>[<span class="type">A</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">A</span>, y: <span class="type">A</span>) = x.compare(y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上下文边界和-implicitly"><a href="#上下文边界和-implicitly" class="headerlink" title="上下文边界和 implicitly[]"></a>上下文边界和 implicitly[]</h3><p>Scala 2.8 引入了一种串联和访问隐式参数的简单记法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>[<span class="type">A</span>](<span class="keyword">implicit</span> x: <span class="type">Ordered</span>[<span class="type">A</span>]) &#123;&#125;</span><br><span class="line">foo: [<span class="type">A</span>](<span class="keyword">implicit</span> x: <span class="type">Ordered</span>[<span class="type">A</span>])<span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>[<span class="type">A</span> : <span class="type">Ordered</span>] &#123;&#125;                        </span><br><span class="line">foo: [<span class="type">A</span>](<span class="keyword">implicit</span> evidence$<span class="number">1</span>: <span class="type">Ordered</span>[<span class="type">A</span>])<span class="type">Unit</span></span><br></pre></td></tr></table></figure><p>隐式值可以通过 <code>implicitly</code> 被访问</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; implicitly[<span class="type">Ordering</span>[<span class="type">Int</span>]]</span><br><span class="line">res37: <span class="type">Ordering</span>[<span class="type">Int</span>] = scala.math.<span class="type">Ordering</span>$<span class="type">Int</span>$@<span class="number">3</span>a9291cf</span><br></pre></td></tr></table></figure><p>相结合后往往会使用更少的代码，尤其是串联视图的时候。</p><h3 id="高阶多态性类型和特设多态性"><a href="#高阶多态性类型和特设多态性" class="headerlink" title="高阶多态性类型和特设多态性"></a>高阶多态性类型和特设多态性</h3><p>Scala 可以对“高阶”的类型进行抽象。例如，假设你需要用几种类型的容器处理几种类型的数据。你可能定义了一个 Container 的接口，它可以被实现为几种类型的容器：Option、List 等。你要定义可以使用这些容器里的值的接口，但不想确定值的类型。</p><p>这类似于函数柯里化。例如，尽管“一元类型”有类似 List[A] 的构造器，这意味着我们必须满足一个“级别”的类型变量来产生一个具体的类型（就像一个没有柯里化的函数需要只提供一个参数列表来被调用），更高阶的类型需要更多。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">trait</span> <span class="title">Container</span>[<span class="type">M</span>[_]] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>[<span class="type">A</span>](x: <span class="type">A</span>): <span class="type">M</span>[<span class="type">A</span>]; <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>[<span class="type">A</span>](m: <span class="type">M</span>[<span class="type">A</span>]): <span class="type">A</span> &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> container = <span class="keyword">new</span> <span class="type">Container</span>[<span class="type">List</span>] &#123; <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>[<span class="type">A</span>](x: <span class="type">A</span>) = <span class="type">List</span>(x); <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>[<span class="type">A</span>](m: <span class="type">List</span>[<span class="type">A</span>]) = m.head &#125;</span><br><span class="line">container: java.lang.<span class="type">Object</span> <span class="keyword">with</span> <span class="type">Container</span>[<span class="type">List</span>] = $anon$<span class="number">1</span>@<span class="number">7</span>c8e3f75</span><br><span class="line"></span><br><span class="line">scala&gt; container.put(<span class="string">"hey"</span>)</span><br><span class="line">res24: <span class="type">List</span>[java.lang.<span class="type">String</span>] = <span class="type">List</span>(hey)</span><br><span class="line"></span><br><span class="line">scala&gt; container.put(<span class="number">123</span>)</span><br><span class="line">res25: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>注意：<em>Container</em> 是参数化类型的多态（“容器类型”）。</p><p>如果我们结合隐式转换 implicits 使用容器，我们会得到“特设的”多态性：即对容器写泛型函数的能力。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">trait</span> <span class="title">Container</span>[<span class="type">M</span>[_]] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>[<span class="type">A</span>](x: <span class="type">A</span>): <span class="type">M</span>[<span class="type">A</span>]; <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>[<span class="type">A</span>](m: <span class="type">M</span>[<span class="type">A</span>]): <span class="type">A</span> &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">implicit</span> <span class="keyword">val</span> listContainer = <span class="keyword">new</span> <span class="type">Container</span>[<span class="type">List</span>] &#123; <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>[<span class="type">A</span>](x: <span class="type">A</span>) = <span class="type">List</span>(x); <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>[<span class="type">A</span>](m: <span class="type">List</span>[<span class="type">A</span>]) = m.head &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">implicit</span> <span class="keyword">val</span> optionContainer = <span class="keyword">new</span> <span class="type">Container</span>[<span class="type">Some</span>] &#123; <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>[<span class="type">A</span>](x: <span class="type">A</span>) = <span class="type">Some</span>(x); <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>[<span class="type">A</span>](m: <span class="type">Some</span>[<span class="type">A</span>]) = m.get &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">tupleize</span></span>[<span class="type">M</span>[_]: <span class="type">Container</span>, <span class="type">A</span>, <span class="type">B</span>](fst: <span class="type">M</span>[<span class="type">A</span>], snd: <span class="type">M</span>[<span class="type">B</span>]) = &#123;</span><br><span class="line">     | <span class="keyword">val</span> c = implicitly[<span class="type">Container</span>[<span class="type">M</span>]]                             </span><br><span class="line">     | c.put(c.get(fst), c.get(snd))</span><br><span class="line">     | &#125;</span><br><span class="line">tupleize: [<span class="type">M</span>[_],<span class="type">A</span>,<span class="type">B</span>](fst: <span class="type">M</span>[<span class="type">A</span>],snd: <span class="type">M</span>[<span class="type">B</span>])(<span class="keyword">implicit</span> evidence$<span class="number">1</span>: <span class="type">Container</span>[<span class="type">M</span>])<span class="type">M</span>[(<span class="type">A</span>, <span class="type">B</span>)]</span><br><span class="line"></span><br><span class="line">scala&gt; tupleize(<span class="type">Some</span>(<span class="number">1</span>), <span class="type">Some</span>(<span class="number">2</span>))</span><br><span class="line">res33: <span class="type">Some</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = <span class="type">Some</span>((<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; tupleize(<span class="type">List</span>(<span class="number">1</span>), <span class="type">List</span>(<span class="number">2</span>))</span><br><span class="line">res34: <span class="type">List</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="F-界多态性"><a href="#F-界多态性" class="headerlink" title="F-界多态性"></a>F-界多态性</h3><p>通常有必要来访问一个泛型 trait 的具体子类。例如，想象你有一些泛型 trait，但需要可以与它的某一子类进行比较。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">Container</span>]</span></span><br></pre></td></tr></table></figure><p>现在子类必须实现 <code>compare</code> 方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">Container</span>): <span class="type">Int</span></span><br></pre></td></tr></table></figure><p>但我们不能访问具体子类型，例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContainer</span> <span class="keyword">extends</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">MyContainer</span>): <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译失败，因为我们对 Container 指定了 Ordered 特质，而不是对特定子类型指定的。</p><p>一个可选的解决方案是将 Container 参数化，以便我们能在子类中访问其子类型。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Container</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">A</span>]</span></span><br></pre></td></tr></table></figure><p>现在子类可以这样做：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContainer</span> <span class="keyword">extends</span> <span class="title">Container</span>[<span class="type">MyContainer</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">MyContainer</span>): <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但问题在于 A 类型没有被任何东西约束，这导致你可能会做类似这样的事情：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContainer</span> <span class="keyword">extends</span> <span class="title">Container</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">String</span>): <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了调和这一点，我们改用 F-界的多态性。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Container</span>[<span class="type">A</span> &lt;: <span class="type">Container</span>[<span class="type">A</span>]] <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">A</span>]</span></span><br></pre></td></tr></table></figure><p>奇怪的类型！但注意现在如何用 A 作为 Ordered 的类型参数，而 A 本身就是 Container[A]</p><p>所以，现在</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContainer</span> <span class="keyword">extends</span> <span class="title">Container</span>[<span class="type">MyContainer</span>] </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">MyContainer</span>) = <span class="number">0</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他们是有序的了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">List</span>(<span class="keyword">new</span> <span class="type">MyContainer</span>, <span class="keyword">new</span> <span class="type">MyContainer</span>, <span class="keyword">new</span> <span class="type">MyContainer</span>)</span><br><span class="line">res3: <span class="type">List</span>[<span class="type">MyContainer</span>] = <span class="type">List</span>(<span class="type">MyContainer</span>@<span class="number">30</span>f02a6d, <span class="type">MyContainer</span>@<span class="number">67717334</span>, <span class="type">MyContainer</span>@<span class="number">49428</span>ffa)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="type">List</span>(<span class="keyword">new</span> <span class="type">MyContainer</span>, <span class="keyword">new</span> <span class="type">MyContainer</span>, <span class="keyword">new</span> <span class="type">MyContainer</span>).min</span><br><span class="line">res4: <span class="type">MyContainer</span> = <span class="type">MyContainer</span>@<span class="number">33</span>dfeb30</span><br></pre></td></tr></table></figure><p>鉴于他们都是 Container[_] 的子类型，我们可以定义另一个子类并创建 Container[_] 的一个混合列表：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">YourContainer</span> <span class="keyword">extends</span> <span class="title">Container</span>[<span class="type">YourContainer</span>] </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">YourContainer</span>) = <span class="number">0</span> &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">YourContainer</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">List</span>(<span class="params">new <span class="type">MyContainer</span>, new <span class="type">MyContainer</span>, new <span class="type">MyContainer</span>, new <span class="type">YourContainer</span></span>)                   </span></span><br><span class="line"><span class="class"><span class="title">res2</span></span>: <span class="type">List</span>[<span class="type">Container</span>[_ &gt;: <span class="type">YourContainer</span> <span class="keyword">with</span> <span class="type">MyContainer</span> &lt;: <span class="type">Container</span>[_ &gt;: <span class="type">YourContainer</span> <span class="keyword">with</span> <span class="type">MyContainer</span> &lt;: <span class="type">ScalaObject</span>]]] </span><br><span class="line">  = <span class="type">List</span>(<span class="type">MyContainer</span>@<span class="number">3</span>be5d207, <span class="type">MyContainer</span>@<span class="number">6</span>d3fe849, <span class="type">MyContainer</span>@<span class="number">7</span>eab48a7, <span class="type">YourContainer</span>@<span class="number">1</span>f2f0ce9)</span><br></pre></td></tr></table></figure><p>注意现在结果类型是由 YourContainer with MyContainer 类型确定的下界。这是类型推断器的工作。有趣的是，这种类型甚至不需要是有意义的，它仅仅对列表的统一类型提供了一个逻辑上最优的下界。如果现在我们尝试使用 Ordered 会发生什么？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="type">MyContainer</span>, <span class="keyword">new</span> <span class="type">MyContainer</span>, <span class="keyword">new</span> <span class="type">MyContainer</span>, <span class="keyword">new</span> <span class="type">YourContainer</span>).min</span><br><span class="line">&lt;console&gt;:<span class="number">9</span>: error: could not find <span class="keyword">implicit</span> value <span class="keyword">for</span> parameter cmp:</span><br><span class="line">  <span class="type">Ordering</span>[<span class="type">Container</span>[_ &gt;: <span class="type">YourContainer</span> <span class="keyword">with</span> <span class="type">MyContainer</span> &lt;: <span class="type">Container</span>[_ &gt;: <span class="type">YourContainer</span> <span class="keyword">with</span> <span class="type">MyContainer</span> &lt;: <span class="type">ScalaObject</span>]]]</span><br></pre></td></tr></table></figure><p>对统一的类型 Ordered[] 不存在了。太糟糕了。</p><h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>Scala 支持结构类型（<code>structural types</code>） — 类型需求由接口结构表示，而不是由具体的类型表示。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>(x: &#123; <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">Int</span> &#125;) = <span class="number">123</span> + x.get</span><br><span class="line">foo: (x: <span class="type">AnyRef</span>&#123;<span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">Int</span>&#125;)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; foo(<span class="keyword">new</span> &#123; <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= <span class="number">10</span> &#125;)                 </span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">133</span></span><br></pre></td></tr></table></figure><p>这可能在很多场景都是相当不错的，但这个实现中使用了反射，所以要<code>注意性能</code>！</p><h3 id="抽象类型成员"><a href="#抽象类型成员" class="headerlink" title="抽象类型成员"></a>抽象类型成员</h3><p>在特质中，你可以让类型成员保持抽象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span> </span>&#123; <span class="class"><span class="keyword">type</span> <span class="title">A</span></span>; <span class="keyword">val</span> x: <span class="type">A</span>; <span class="function"><span class="keyword">def</span> <span class="title">getX</span></span>: <span class="type">A</span> = x &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> (<span class="params">new <span class="type">Foo</span> &#123; type <span class="type">A</span> = <span class="type">Int</span>; val x = 123 &#125;</span>).<span class="title">getX</span>   </span></span><br><span class="line"><span class="class"><span class="title">res3</span></span>: <span class="type">Int</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">scala&gt; (<span class="keyword">new</span> <span class="type">Foo</span> &#123; <span class="class"><span class="keyword">type</span> <span class="title">A</span> </span>= <span class="type">String</span>; <span class="keyword">val</span> x = <span class="string">"hey"</span> &#125;).getX</span><br><span class="line">res4: java.lang.<span class="type">String</span> = hey</span><br></pre></td></tr></table></figure><p>在做<code>依赖注入</code>等情况下，这往往是一个有用的技巧。</p><p>你可以使用 hash 操作符来引用一个抽象类型的变量：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span>[<span class="type">M</span>[_]] </span>&#123; <span class="class"><span class="keyword">type</span> <span class="title">t</span>[<span class="type">A</span>] </span>= <span class="type">M</span>[<span class="type">A</span>] &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">x</span></span>: <span class="type">Foo</span>[<span class="type">List</span>]#t[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>)</span><br><span class="line">x: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="类型擦除和清单"><a href="#类型擦除和清单" class="headerlink" title="类型擦除和清单"></a>类型擦除和清单</h3><p>正如我们所知道的，类型信息在编译的时候会因为擦除而丢失。 Scala 提供了清单（<code>Manifests</code>）功能，使我们能够选择性地恢复类型信息。清单作为一个隐式的值被提供，它由编译器根据需要生成。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">MakeFoo</span>[<span class="type">A</span>](<span class="params">implicit manifest: <span class="type">Manifest</span>[<span class="type">A</span>]</span>) </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">make</span></span>: <span class="type">A</span> = manifest.erasure.newInstance.asInstanceOf[<span class="type">A</span>] &#125;</span><br><span class="line"></span><br><span class="line">scala&gt; (<span class="keyword">new</span> <span class="type">MakeFoo</span>[<span class="type">String</span>]).make</span><br><span class="line">res10: <span class="type">String</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure><h3 id="案例分析：Finagle"><a href="#案例分析：Finagle" class="headerlink" title="案例分析：Finagle"></a>案例分析：Finagle</h3><p>参见：<a href="https://github.com/twitter/finagle" target="_blank" rel="noopener">https://github.com/twitter/finagle</a></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Service</span>[-<span class="type">Req</span>, +<span class="type">Rep</span>] <span class="keyword">extends</span> (<span class="params"><span class="type">Req</span> =&gt; <span class="type">Future</span>[<span class="type">Rep</span>]</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">Filter</span>[-<span class="type">ReqIn</span>, +<span class="type">RepOut</span>, +<span class="type">ReqOut</span>, -<span class="type">RepIn</span>]</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> (<span class="params">(<span class="type">ReqIn</span>, <span class="type">Service</span>[<span class="type">ReqOut</span>, <span class="type">RepIn</span>]</span>) <span class="title">=&gt;</span> <span class="title">Future</span>[<span class="type">RepOut</span>])</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>[<span class="type">Req2</span>, <span class="type">Rep2</span>](next: <span class="type">Filter</span>[<span class="type">ReqOut</span>, <span class="type">RepIn</span>, <span class="type">Req2</span>, <span class="type">Rep2</span>]) =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Filter</span>[<span class="type">ReqIn</span>, <span class="type">RepOut</span>, <span class="type">Req2</span>, <span class="type">Rep2</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(request: <span class="type">ReqIn</span>, service: <span class="type">Service</span>[<span class="type">Req2</span>, <span class="type">Rep2</span>]) = &#123;</span><br><span class="line">        <span class="type">Filter</span>.<span class="keyword">this</span>.apply(request, <span class="keyword">new</span> <span class="type">Service</span>[<span class="type">ReqOut</span>, <span class="type">RepIn</span>] &#123;</span><br><span class="line">          <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(request: <span class="type">ReqOut</span>): <span class="type">Future</span>[<span class="type">RepIn</span>] = next(request, service)</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">release</span></span>() = service.release()</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isAvailable</span> </span>= service.isAvailable</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">andThen</span></span>(service: <span class="type">Service</span>[<span class="type">ReqOut</span>, <span class="type">RepIn</span>]) = <span class="keyword">new</span> <span class="type">Service</span>[<span class="type">ReqIn</span>, <span class="type">RepOut</span>] &#123;</span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> refcounted = <span class="keyword">new</span> <span class="type">RefcountedService</span>(service)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(request: <span class="type">ReqIn</span>) = <span class="type">Filter</span>.<span class="keyword">this</span>.apply(request, refcounted)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">release</span></span>() = refcounted.release()</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isAvailable</span> </span>= refcounted.isAvailable</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个服务可以通过过滤器对请求进行身份验证。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">RequestWithCredentials</span> <span class="keyword">extends</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">credentials</span></span>: <span class="type">Credentials</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CredentialsFilter</span>(<span class="params">credentialsParser: <span class="type">CredentialsParser</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Filter</span>[<span class="type">Request</span>, <span class="type">Response</span>, <span class="type">RequestWithCredentials</span>, <span class="type">Response</span>]</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(request: <span class="type">Request</span>, service: <span class="type">Service</span>[<span class="type">RequestWithCredentials</span>, <span class="type">Response</span>]): <span class="type">Future</span>[<span class="type">Response</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> requestWithCredentials = <span class="keyword">new</span> <span class="type">RequestWrapper</span> <span class="keyword">with</span> <span class="type">RequestWithCredentials</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> underlying = request</span><br><span class="line">      <span class="keyword">val</span> credentials = credentialsParser(request) getOrElse <span class="type">NullCredentials</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    service(requestWithCredentials)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意底层服务是如何需要对请求进行身份验证的，而且还是静态验证。因此，过滤器可以被看作是服务转换器。</p><p>许多过滤器可以被组合在一起：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> upFilter =</span><br><span class="line">  logTransaction     andThen</span><br><span class="line">  handleExceptions   andThen</span><br><span class="line">  extractCredentials andThen</span><br><span class="line">  homeUser           andThen</span><br><span class="line">  authenticate       andThen</span><br><span class="line">  route</span><br></pre></td></tr></table></figure><p>享用安全的类型吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;视界（View-Bound-“类型类”）&quot;&gt;&lt;a href=&quot;#视界（View-Bound-“类型类”）&quot; class=&quot;headerlink&quot; title=&quot;视界（View Bound “类型类”）&quot;&gt;&lt;/a&gt;视界（View Bound “类型类”）&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>类型和多态基础</title>
    <link href="https://razertory.me/2019/12/01/scala-school-type-basics/"/>
    <id>https://razertory.me/2019/12/01/scala-school-type-basics/</id>
    <published>2019-12-01T02:47:32.000Z</published>
    <updated>2020-05-04T07:03:04.626Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是静态类型？它们为什么有用？"><a href="#什么是静态类型？它们为什么有用？" class="headerlink" title="什么是静态类型？它们为什么有用？"></a>什么是静态类型？它们为什么有用？</h4><blockquote><p>按 Pierce 的话讲：“类型系统是一个语法方法，它们根据程序计算的值的种类对程序短语进行分类，通过分类结果错误行为进行自动检查。” 另外，笔者推荐阅读 <a href="https://www.zhihu.com/question/23434097" target="_blank" rel="noopener">编程语言的类型系统为何如此重要？</a></p></blockquote><p>类型允许你表示函数的定义域和值域。例如，从数学角度看这个定义：</p><p><code>f: R -&gt; N</code> // 它告诉我们函数 f 是从实数集到自然数集的映射。</p><p>抽象地说，这就是<em>具体</em>类型的准确定义。类型系统给我们提供了一些更强大的方式来表达这些集合。鉴于这些注释，编译器可以<em>静态地</em>（在编译时）验证程序是<em>合理</em>的。也就是说，如果值（在运行时）不符合程序规定的约束，编译将失败。一般说来，类型检查只能保证<em>不合理</em>的程序不能编译通过。它不能保证每一个合理的程序都<em>可以</em>编译通过。</p><p>随着类型系统表达能力的提高，我们可以生产更可靠的代码，因为它能够在我们运行程序之前验证程序的不变性（当然是发现类型本身的模型 bug！）。学术界一直很努力地提高类型系统的表现力，包括值依赖（value-dependent）类型！</p><p>需要注意的是，所有的类型信息会在编译时被删去，因为它已不再需要。这就是所谓的<code>类型擦除</code>。</p><h4 id="Scala-中的类型"><a href="#Scala-中的类型" class="headerlink" title="Scala 中的类型"></a>Scala 中的类型</h4><p>Scala 强大的类型系统拥有非常丰富的表现力。其主要特性有：</p><ul><li><strong>参数化多态性 (parametric polymorphism )</strong>，粗略地说，就是泛型编程</li><li><strong>局部类型推断</strong>，粗略地说，就是为什么你不需要这样写代码 val i: Int = 12: Int</li><li>*<em>存在量化 (existential quantification) *</em>粗略地说，为一些没有名称的类型进行定义</li><li>*<em>视图 (views) *</em>粗略地说，就是将一种类型的值“强制转换”为另一种类型</li></ul><h4 id="参数化多态性"><a href="#参数化多态性" class="headerlink" title="参数化多态性"></a>参数化多态性</h4><p>多态性是在不影响静态类型丰富性的前提下，用来（给不同类型的值）编写通用代码的。</p><p>例如，如果没有参数化多态性，一个通用的列表数据结构总是看起来像这样（事实上，它看起来很像使用泛型前的 Java）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="number">2</span> :: <span class="number">1</span> :: <span class="string">"bar"</span> :: <span class="string">"foo"</span> :: <span class="type">Nil</span></span><br><span class="line">res5: <span class="type">List</span>[<span class="type">Any</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">1</span>, bar, foo)</span><br></pre></td></tr></table></figure><p>现在我们无法恢复其中成员的任何类型信息。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; res5.head</span><br><span class="line">res6: <span class="type">Any</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>所以我们的应用程序将会退化为一系列类型转换（“asInstanceOf[]”），并且会缺乏类型安全的保障（因为这些都是动态的）。</p><p>多态性是通过指定<em>类型变量</em>实现的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">drop1</span></span>[<span class="type">A</span>](l: <span class="type">List</span>[<span class="type">A</span>]) = l.tail</span><br><span class="line">drop1: [<span class="type">A</span>](l: <span class="type">List</span>[<span class="type">A</span>])<span class="type">List</span>[<span class="type">A</span>]</span><br><span class="line"></span><br><span class="line">scala&gt; drop1(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">res1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="Scala-有-rank-1-多态性-rank-1-polymorphism"><a href="#Scala-有-rank-1-多态性-rank-1-polymorphism" class="headerlink" title="Scala 有 rank-1 多态性 (rank-1 polymorphism)"></a>Scala 有 rank-1 多态性 (rank-1 polymorphism)</h4><p>粗略地说，这意味着在 Scala 中，有一些你想表达的类型概念“过于泛化”（泛化的层级大于 1) 以至于编译器无法理解。假设你有一个函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toList</span></span>[<span class="type">A</span>](a: <span class="type">A</span>) = <span class="type">List</span>(a)</span><br></pre></td></tr></table></figure><p>你希望继续泛型地使用它：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>[<span class="type">A</span>, <span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">A</span>], b: <span class="type">B</span>) = f(b)</span><br></pre></td></tr></table></figure><p>这段代码不能编译，因为所有的类型变量只有在调用上下文中才被固定。即使你“钉住”了类型 B：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span>[<span class="type">A</span>](f: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">A</span>], i: <span class="type">Int</span>) = f(i)</span><br></pre></td></tr></table></figure><p>你也会得到一个类型不匹配的错误。</p><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>静态类型的一个传统反对意见是，它有大量的语法开销。Scala 通过<em>类型推断</em>来缓解这个问题。</p><p>在函数式编程语言中，类型推断的经典方法是 Hindley Milner 算法，它最早是实现在 ML 中的。</p><p>Scala 类型推断系统的实现稍有不同，但本质类似：<code>推断约束</code>，并试图统一类型。</p><p>例如，在 Scala 中你无法这样做：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; &#123; x =&gt; x &#125;</span><br><span class="line">&lt;console&gt;:<span class="number">7</span>: error: missing parameter <span class="class"><span class="keyword">type</span></span></span><br><span class="line"><span class="class">       </span>&#123; x =&gt; x &#125;</span><br></pre></td></tr></table></figure><p>而在 OCaml 中你可以：</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">fun</span> x -&gt; x;;</span><br><span class="line">- : <span class="symbol">'a</span> -&gt; <span class="symbol">'a</span> = &lt;<span class="keyword">fun</span>&gt;</span><br></pre></td></tr></table></figure><p>在 Scala 中所有类型推断是<code>局部的</code>。Scala 一次分析一个表达式。例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">id</span></span>[<span class="type">T</span>](x: <span class="type">T</span>) = x</span><br><span class="line">id: [<span class="type">T</span>](x: <span class="type">T</span>)<span class="type">T</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> x = id(<span class="number">322</span>)</span><br><span class="line">x: <span class="type">Int</span> = <span class="number">322</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> x = id(<span class="string">"hey"</span>)</span><br><span class="line">x: java.lang.<span class="type">String</span> = hey</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> x = id(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">x: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>类型信息都保存完好，Scala 编译器为我们进行了类型推断。请注意我们并不需要明确指定返回类型。</p><h4 id="变性-Variance"><a href="#变性-Variance" class="headerlink" title="变性 (Variance)"></a>变性 (Variance)</h4><p>Scala 的类型系统必须同时解释类层次和多态性。类层次结构可以表达子类关系。在混合 OO 和多态性时，一个核心问题是：如果 T’是 T 一个子类，Container[T’] 应该被看做是 Container[T] 的子类吗？变性（Variance）注解允许你表达类层次结构和多态类型之间的关系。</p><table><thead><tr><th></th><th>含义</th><th>Scala 标记</th></tr></thead><tbody><tr><td>协变 (covariant)</td><td>C[T’] 是 C[T] 的子类</td><td>[+T]</td></tr><tr><td>逆变 (contravariant)</td><td>C[T] 是 C[T’] 的子类</td><td>[-T]</td></tr><tr><td>不变 (invariant)</td><td>C[T] 和 C[T’] 无关</td><td>[T]</td></tr></tbody></table><blockquote><p>逆变协变更多信息参考<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>子类型关系的真正含义：对一个给定的类型 T，如果 T’是其子类型，你能替换它吗？</p><h5 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Covariant</span>[+<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">defined</span> <span class="title">class</span> <span class="title">Covariant</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">cv</span></span>: <span class="type">Covariant</span>[<span class="type">AnyRef</span>] = <span class="keyword">new</span> <span class="type">Covariant</span>[<span class="type">String</span>]</span><br><span class="line">cv: <span class="type">Covariant</span>[<span class="type">AnyRef</span>] = <span class="type">Covariant</span>@<span class="number">4035</span>acf6</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> cv: <span class="type">Covariant</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Covariant</span>[<span class="type">AnyRef</span>]</span><br><span class="line">&lt;console&gt;:<span class="number">6</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line"> found   : <span class="type">Covariant</span>[<span class="type">AnyRef</span>]</span><br><span class="line"> required: <span class="type">Covariant</span>[<span class="type">String</span>]</span><br><span class="line">       <span class="keyword">val</span> cv: <span class="type">Covariant</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Covariant</span>[<span class="type">AnyRef</span>]</span><br><span class="line">                                   ^</span><br></pre></td></tr></table></figure><h5 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Contravariant</span>[-<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">defined</span> <span class="title">class</span> <span class="title">Contravariant</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">cv</span></span>: <span class="type">Contravariant</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Contravariant</span>[<span class="type">AnyRef</span>]</span><br><span class="line">cv: <span class="type">Contravariant</span>[<span class="type">AnyRef</span>] = <span class="type">Contravariant</span>@<span class="number">49</span>fa7ba</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> fail: <span class="type">Contravariant</span>[<span class="type">AnyRef</span>] = <span class="keyword">new</span> <span class="type">Contravariant</span>[<span class="type">String</span>]</span><br><span class="line">&lt;console&gt;:<span class="number">6</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line"> found   : <span class="type">Contravariant</span>[<span class="type">String</span>]</span><br><span class="line"> required: <span class="type">Contravariant</span>[<span class="type">AnyRef</span>]</span><br><span class="line">       <span class="keyword">val</span> fail: <span class="type">Contravariant</span>[<span class="type">AnyRef</span>] = <span class="keyword">new</span> <span class="type">Contravariant</span>[<span class="type">String</span>]</span><br><span class="line">                                     ^</span><br></pre></td></tr></table></figure><p>逆变似乎很奇怪。什么时候才会用到它呢？令人惊讶的是，函数特质的定义就使用了它！</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span> [-<span class="type">T1</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span></span></span><br></pre></td></tr></table></figure><p>如果你仔细从替换的角度思考一下，会发现它是非常合理的。让我们先定义一个简单的类层次结构：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; <span class="keyword">val</span> sound = <span class="string">"rustle"</span> &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; <span class="keyword">override</span> <span class="keyword">val</span> sound = <span class="string">"call"</span> &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">class</span> <span class="title">Chicken</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123; <span class="keyword">override</span> <span class="keyword">val</span> sound = <span class="string">"cluck"</span> &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Chicken</span></span></span><br></pre></td></tr></table></figure><p>假设你需要一个以 Bird 为参数的函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> getTweet: (<span class="type">Bird</span> =&gt; <span class="type">String</span>) = <span class="comment">// TODO</span></span><br></pre></td></tr></table></figure><p>标准动物库有一个函数满足了你的需求，但它的参数是 Animal。在大多数情况下，如果你说“我需要一个<strong><em>，我有一个</em></strong>的子类”是可以的。但是，在函数参数这里是<code>逆变</code>的。如果你需要一个接受参数类型 Bird 的函数变量，但却将这个变量指向了接受参数类型为 Chicken 的函数，那么给它传入一个 Duck 时就会出错。然而，如果将该变量指向一个接受参数类型为 Animal 的函数就不会有这种问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> getTweet: (<span class="type">Bird</span> =&gt; <span class="type">String</span>) = ((a: <span class="type">Animal</span>) =&gt; a.sound )</span><br><span class="line">getTweet: <span class="type">Bird</span> =&gt; <span class="type">String</span> = &lt;function1&gt;</span><br></pre></td></tr></table></figure><p>函数的返回值类型是协变的。如果你需要一个返回 Bird 的函数，但指向的函数返回类型是 Chicken，这当然是可以的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> hatch: (() =&gt; <span class="type">Bird</span>) = (() =&gt; <span class="keyword">new</span> <span class="type">Chicken</span> )</span><br><span class="line">hatch: () =&gt; <span class="type">Bird</span> = &lt;function0&gt;</span><br></pre></td></tr></table></figure><blockquote><p>所以对于 Scala 中的函数而言，在入参逆变，返回值协变的基础上一切都会变得灵活而严谨。</p></blockquote><h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><p>Scala 允许你通过<code>边界</code>来限制多态变量。这些边界表达了子类型关系。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">cacophony</span></span>[<span class="type">T</span>](things: <span class="type">Seq</span>[<span class="type">T</span>]) = things map (_.sound)</span><br><span class="line">&lt;console&gt;:<span class="number">7</span>: error: value sound is not a member of <span class="class"><span class="keyword">type</span> <span class="title">parameter</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">       <span class="title">def</span> <span class="title">cacophony</span>[<span class="type">T</span>](<span class="params">things: <span class="type">Seq</span>[<span class="type">T</span>]</span>) </span>= things map (_.sound)</span><br><span class="line">                                                        ^</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">biophony</span></span>[<span class="type">T</span> &lt;: <span class="type">Animal</span>](things: <span class="type">Seq</span>[<span class="type">T</span>]) = things map (_.sound)</span><br><span class="line">biophony: [<span class="type">T</span> &lt;: <span class="type">Animal</span>](things: <span class="type">Seq</span>[<span class="type">T</span>])<span class="type">Seq</span>[java.lang.<span class="type">String</span>]</span><br><span class="line"></span><br><span class="line">scala&gt; biophony(<span class="type">Seq</span>(<span class="keyword">new</span> <span class="type">Chicken</span>, <span class="keyword">new</span> <span class="type">Bird</span>))</span><br><span class="line">res5: <span class="type">Seq</span>[java.lang.<span class="type">String</span>] = <span class="type">List</span>(cluck, call)</span><br></pre></td></tr></table></figure><p>类型下界也是支持的，这让逆变和巧妙协变的引入得心应手。List[+T] 是协变的；一个 Bird 的列表也是 Animal 的列表。List 定义一个操作 <code>::</code> (elem T) 返回一个加入了 elem 的新的 List。新的 List 和原来的列表具有相同的类型：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> flock = <span class="type">List</span>(<span class="keyword">new</span> <span class="type">Bird</span>, <span class="keyword">new</span> <span class="type">Bird</span>)</span><br><span class="line">flock: <span class="type">List</span>[<span class="type">Bird</span>] = <span class="type">List</span>(<span class="type">Bird</span>@<span class="number">7e1</span>ec70e, <span class="type">Bird</span>@<span class="number">169</span>ea8d2)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">new</span> <span class="type">Chicken</span> :: flock</span><br><span class="line">res53: <span class="type">List</span>[<span class="type">Bird</span>] = <span class="type">List</span>(<span class="type">Chicken</span>@<span class="number">56</span>fbda05, <span class="type">Bird</span>@<span class="number">7e1</span>ec70e, <span class="type">Bird</span>@<span class="number">169</span>ea8d2)</span><br></pre></td></tr></table></figure><p>List 同样 定义了 <code>::</code> [B &gt;: T](x: B) 来返回一个 List[B]。请注意 B &gt;: T，这指明了类型 B 为类型 T 的超类。这个方法让我们能够做正确地处理在一个 List[Bird] 前面加一个 Animal 的操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">new</span> <span class="type">Animal</span> :: flock</span><br><span class="line">res59: <span class="type">List</span>[<span class="type">Animal</span>] = <span class="type">List</span>(<span class="type">Animal</span>@<span class="number">11</span>f8d3a8, <span class="type">Bird</span>@<span class="number">7e1</span>ec70e, <span class="type">Bird</span>@<span class="number">169</span>ea8d2)</span><br></pre></td></tr></table></figure><p>注意返回类型是 Animal。</p><h4 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h4><p>有时候，你并不关心是否能够命名一个类型变量，例如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">count</span></span>[<span class="type">A</span>](l: <span class="type">List</span>[<span class="type">A</span>]) = l.size</span><br><span class="line">count: [<span class="type">A</span>](<span class="type">List</span>[<span class="type">A</span>])<span class="type">Int</span></span><br></pre></td></tr></table></figure><p>这时你可以使用通配符 <code>_</code> 取而代之：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(l: <span class="type">List</span>[_]) = l.size</span><br><span class="line">count: (<span class="type">List</span>[_])<span class="type">Int</span></span><br></pre></td></tr></table></figure><p>这相当于是下面代码的简写：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(l: <span class="type">List</span>[<span class="type">T</span> <span class="keyword">forSome</span> &#123; <span class="class"><span class="keyword">type</span> <span class="title">T</span> &#125;]) </span>= l.size</span><br><span class="line">count: (<span class="type">List</span>[<span class="type">T</span> <span class="keyword">forSome</span> &#123; <span class="class"><span class="keyword">type</span> <span class="title">T</span> &#125;])<span class="title">Int</span></span></span><br></pre></td></tr></table></figure><p>注意量化会的结果会变得非常难以理解：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">drop1</span></span>(l: <span class="type">List</span>[_]) = l.tail</span><br><span class="line">drop1: (<span class="type">List</span>[_])<span class="type">List</span>[<span class="type">Any</span>]</span><br></pre></td></tr></table></figure><p>突然，我们失去了类型信息！让我们细化代码看看发生了什么：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">drop1</span></span>(l: <span class="type">List</span>[<span class="type">T</span> <span class="keyword">forSome</span> &#123; <span class="class"><span class="keyword">type</span> <span class="title">T</span> &#125;]) </span>= l.tail</span><br><span class="line">drop1: (<span class="type">List</span>[<span class="type">T</span> <span class="keyword">forSome</span> &#123; <span class="class"><span class="keyword">type</span> <span class="title">T</span> &#125;])<span class="title">List</span>[<span class="type">T</span> forSome &#123; type <span class="type">T</span> &#125;]</span></span><br></pre></td></tr></table></figure><p>我们不能使用 T 因为类型不允许这样做。</p><p>你也可以为通配符类型变量应用边界：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">hashcodes</span></span>(l: <span class="type">Seq</span>[_ &lt;: <span class="type">AnyRef</span>]) = l map (_.hashCode)</span><br><span class="line">hashcodes: (<span class="type">Seq</span>[_ &lt;: <span class="type">AnyRef</span>])<span class="type">Seq</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">scala&gt; hashcodes(<span class="type">Seq</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">&lt;console&gt;:<span class="number">7</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line"> found   : <span class="type">Int</span>(<span class="number">1</span>)</span><br><span class="line"> required: <span class="type">AnyRef</span></span><br><span class="line"><span class="type">Note</span>: primitive types are not implicitly converted to <span class="type">AnyRef</span>.</span><br><span class="line"><span class="type">You</span> can safely force boxing by casting x.asInstanceOf[<span class="type">AnyRef</span>].</span><br><span class="line">       hashcodes(<span class="type">Seq</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">                     ^</span><br><span class="line"></span><br><span class="line">scala&gt; hashcodes(<span class="type">Seq</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>))</span><br><span class="line">res1: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">110182</span>, <span class="number">115276</span>, <span class="number">110339486</span>)</span><br></pre></td></tr></table></figure><p>参考 <a href="https://www.drmaciver.com/2008/03/existential-types-in-scala/" target="_blank" rel="noopener">D. R. MacIver 写的 Scala 中的存在类型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是静态类型？它们为什么有用？&quot;&gt;&lt;a href=&quot;#什么是静态类型？它们为什么有用？&quot; class=&quot;headerlink&quot; title=&quot;什么是静态类型？它们为什么有用？&quot;&gt;&lt;/a&gt;什么是静态类型？它们为什么有用？&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;按
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>模式匹配与函数组合</title>
    <link href="https://razertory.me/2019/12/01/scala-school-pattern-matching-and-functional-composition/"/>
    <id>https://razertory.me/2019/12/01/scala-school-pattern-matching-and-functional-composition/</id>
    <published>2019-12-01T02:28:36.000Z</published>
    <updated>2020-05-04T07:03:11.841Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h3><p>让我们创建两个函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(s: <span class="type">String</span>) = <span class="string">"f("</span> + s + <span class="string">")"</span></span><br><span class="line">f: (<span class="type">String</span>)java.lang.<span class="type">String</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">g</span></span>(s: <span class="type">String</span>) = <span class="string">"g("</span> + s + <span class="string">")"</span></span><br><span class="line">g: (<span class="type">String</span>)java.lang.<span class="type">String</span></span><br></pre></td></tr></table></figure><h4 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h4><p><code>compose</code> 组合其他函数形成一个新的函数 <code>f(g(x))</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> fComposeG = f _ compose g _</span><br><span class="line">fComposeG: (<span class="type">String</span>) =&gt; java.lang.<span class="type">String</span> = &lt;function&gt;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; fComposeG(<span class="string">"yay"</span>)</span><br><span class="line">res0: java.lang.<span class="type">String</span> = f(g(yay))</span><br></pre></td></tr></table></figure><h4 id="andThen"><a href="#andThen" class="headerlink" title="andThen"></a>andThen</h4><p><code>andThen</code> 和 <code>compose</code> 很像，但是调用顺序是先调用第一个函数，然后调用第二个，即 <code>g(f(x))</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> fAndThenG = f _ andThen g _</span><br><span class="line">fAndThenG: (<span class="type">String</span>) =&gt; java.lang.<span class="type">String</span> = &lt;function&gt;</span><br><span class="line">scala&gt; fAndThenG(<span class="string">"yay"</span>)</span><br><span class="line">res1: java.lang.<span class="type">String</span> = g(f(yay))</span><br></pre></td></tr></table></figure><h3 id="柯里化-Curried-vs-部分应用-Partial-Application"><a href="#柯里化-Curried-vs-部分应用-Partial-Application" class="headerlink" title="柯里化(Curried) vs 部分应用(Partial Application)"></a>柯里化(Curried) vs 部分应用(Partial Application)</h3><h4 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h4><ul><li><p>那么究竟什么是 case 语句？ 这是一个名为 <code>PartialFunction</code> 的函数的子类。</p></li><li><p>多个 case 语句的集合是什么？ 他们是共同组合在一起的多个 <code>PartialFunction</code>。</p></li></ul><blockquote><p>ps: PartialFunction 详见 <a href="https://www.scala-lang.org/api/2.12.9/scala/PartialFunction.html" target="_blank" rel="noopener">https://www.scala-lang.org/api/2.12.9/scala/PartialFunction.html</a></p></blockquote><h4 id="函数-vs-偏函数-PartialFunction"><a href="#函数-vs-偏函数-PartialFunction" class="headerlink" title="函数 vs 偏函数 (PartialFunction)"></a>函数 vs 偏函数 (PartialFunction)</h4><p><strong>函数</strong>: 对给定的输入参数类型，函数可接受该类型的任何值。换句话说，一个 (Int) =&gt; String 的函数可以接收任意 Int 值，并返回一个字符串。</p><p><strong>偏函数</strong>: 对给定的输入参数类型，<code>偏函数</code>只能接受该类型的某些特定的值。一个定义为 (Int) =&gt; String 的<code>偏函数</code>可能不能接受所有 Int 值为输入。<code>isDefinedAt</code> 是偏函数的一个方法，用来确定是否能接受一个给定的参数。注意偏函数和我们前面提到的<code>部分应用</code>函数是无关的。</p><p>参考 Effective Scala 对 <a href="https://twitter.github.com/effectivescala/#Functional%20programming-Partial%20functions" target="_blank" rel="noopener">PartialFunction</a> 的意见。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> one: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123; <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span> &#125;</span><br><span class="line">one: <span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">String</span>] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `isDefinedAt` 是`偏函数`的一个方法，用来确定是否能接受一个给定的参数</span></span><br><span class="line">scala&gt; one.isDefinedAt(<span class="number">1</span>)</span><br><span class="line">res0: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">scala&gt; one.isDefinedAt(<span class="number">2</span>)</span><br><span class="line">res1: <span class="type">Boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>您可以调用一个偏函数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; one(<span class="number">1</span>)</span><br><span class="line">res2: <span class="type">String</span> = one</span><br></pre></td></tr></table></figure><p>偏函数可以使用 <code>orElse</code> 组成新的函数，得到的偏函数反映了是否对给定参数进行了定义。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> two: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123; <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span> &#125;</span><br><span class="line">two: <span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">String</span>] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> three: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123; <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="string">"three"</span> &#125;</span><br><span class="line">three: <span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">String</span>] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> wildcard: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123; <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span> &#125;</span><br><span class="line">wildcard: <span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">String</span>] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> partial = one orElse two orElse three orElse wildcard</span><br><span class="line">partial: <span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">String</span>] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; partial(<span class="number">5</span>)</span><br><span class="line">res24: <span class="type">String</span> = something <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">scala&gt; partial(<span class="number">3</span>)</span><br><span class="line">res25: <span class="type">String</span> = three</span><br><span class="line"></span><br><span class="line">scala&gt; partial(<span class="number">2</span>)</span><br><span class="line">res26: <span class="type">String</span> = two</span><br><span class="line"></span><br><span class="line">scala&gt; partial(<span class="number">1</span>)</span><br><span class="line">res27: <span class="type">String</span> = one</span><br><span class="line"></span><br><span class="line">scala&gt; partial(<span class="number">0</span>)</span><br><span class="line">res28: <span class="type">String</span> = something <span class="keyword">else</span></span><br></pre></td></tr></table></figure><h4 id="case-之谜"><a href="#case-之谜" class="headerlink" title="case 之谜"></a>case 之谜</h4><p><a href="/2019/12/01/scala-school-collections/#drop-amp-dropWhile">上一篇</a> 我们看到一些新奇的东西。我们在通常应该使用函数的地方看到了一个 case 语句。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneExt</span>(<span class="params">name: <span class="type">String</span>, ext: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">defined</span> <span class="title">class</span> <span class="title">PhoneExt</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">extensions</span> </span>= <span class="type">List</span>(<span class="type">PhoneExt</span>(<span class="string">"steve"</span>, <span class="number">100</span>), <span class="type">PhoneExt</span>(<span class="string">"robey"</span>, <span class="number">200</span>))</span><br><span class="line">extensions: <span class="type">List</span>[<span class="type">PhoneExt</span>] = <span class="type">List</span>(<span class="type">PhoneExt</span>(steve,<span class="number">100</span>), <span class="type">PhoneExt</span>(robey,<span class="number">200</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; extensions.filter &#123; <span class="keyword">case</span> <span class="type">PhoneExt</span>(name, extension) =&gt; extension &lt; <span class="number">200</span> &#125;</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">PhoneExt</span>] = <span class="type">List</span>(<span class="type">PhoneExt</span>(steve,<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>为什么这段代码可以工作？</p><p>filter 使用一个函数。在这个例子中是一个<code>谓词函数</code>(PhoneExt) =&gt; Boolean。(返回一个布尔值的函数通常被称为<code>谓词函数</code>)</p><p>偏函数 PartialFunction 是 Function 的<code>子类型</code>，所以 filter 也可以使用 PartialFunction。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数组合&quot;&gt;&lt;a href=&quot;#函数组合&quot; class=&quot;headerlink&quot; title=&quot;函数组合&quot;&gt;&lt;/a&gt;函数组合&lt;/h3&gt;&lt;p&gt;让我们创建两个函数：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala 课堂 - 集合</title>
    <link href="https://razertory.me/2019/12/01/scala-school-collections/"/>
    <id>https://razertory.me/2019/12/01/scala-school-collections/</id>
    <published>2019-12-01T01:10:36.000Z</published>
    <updated>2020-05-04T07:02:42.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>Scala 提供了一些不错的集合。</p><p>参考 Effective Scala 对怎样使用集合的观点。</p><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 (Array)"></a>数组 (Array)</h3><p>数组是有序的，可以包含重复项，并且可变。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> numbers = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">numbers: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers(<span class="number">3</span>) = <span class="number">10</span></span><br><span class="line">scala&gt; numbers</span><br><span class="line">numbers: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 (List)"></a>列表 (List)</h3><p>列表是有序的，可以包含重复项，不可变。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> numbers = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">numbers: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers(<span class="number">3</span>) = <span class="number">10</span></span><br><span class="line">&lt;console&gt;:<span class="number">9</span>: error: value update is not a member of <span class="type">List</span>[<span class="type">Int</span>]</span><br><span class="line">              numbers(<span class="number">3</span>) = <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 (Set)"></a>集合 (Set)</h3><p>集合无序且不可包含重复项。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> numbers = <span class="type">Set</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">numbers: scala.collection.immutable.<span class="type">Set</span>[<span class="type">Int</span>] = <span class="type">Set</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 (Tuple)"></a>元组 (Tuple)</h3><p>元组在不使用类的情况下，将元素组合起来形成简单的逻辑集合。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> hostPort = (<span class="string">"localhost"</span>, <span class="number">80</span>)</span><br><span class="line">hostPort: (<span class="type">String</span>, <span class="type">Int</span>) = (localhost, <span class="number">80</span>)</span><br></pre></td></tr></table></figure><p>与样本类不同，元组不能通过名称获取字段，而是使用位置下标来读取对象；而且这个下标基于 <code>1</code>，而不是基于 0。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; hostPort._1</span><br><span class="line">res0: <span class="type">String</span> = localhost</span><br><span class="line"></span><br><span class="line">scala&gt; hostPort._2</span><br><span class="line">res1: <span class="type">Int</span> = <span class="number">80</span></span><br></pre></td></tr></table></figure><p>元组可以很好得与模式匹配相结合。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hostPort <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="string">"localhost"</span>, port) =&gt; ...</span><br><span class="line">  <span class="keyword">case</span> (host, port) =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建两个元素的元组时，可以使用特殊语法：<code>-&gt;</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="number">1</span> -&gt; <span class="number">2</span></span><br><span class="line">res0: (<span class="type">Int</span>, <span class="type">Int</span>) = (<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>参考 Effective Scala 对 <a href="https://twitter.github.com/effectivescala/#Functional%20programming-Destructuring%20bindings" target="_blank" rel="noopener">解构绑定</a>（“拆解”一个元组）的观点。</p><h3 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射 (Map)"></a>映射 (Map)</h3><p>它可以持有基本数据类型。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">2</span>)</span><br><span class="line"><span class="type">Map</span>(<span class="string">"foo"</span> -&gt; <span class="string">"bar"</span>)</span><br></pre></td></tr></table></figure><p>这看起来像是特殊的语法，不过不要忘了上文讨论的 <code>-&gt;</code> 可以用来创建二元组。</p><p>Map() 方法也使用了从第一节课学到的变参列表：Map(1 -&gt; “one”, 2 -&gt; “two”) 将变为 Map((1, “one”), (2, “two”))，其中第一个元素是映射的键，第二个元素是映射的值。</p><p>映射的值可以是映射甚至是<code>函数</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="type">Map</span>(<span class="string">"foo"</span> -&gt; <span class="string">"bar"</span>))</span><br><span class="line"><span class="type">Map</span>(<span class="string">"timesTwo"</span> -&gt; &#123; timesTwo(_) &#125;)</span><br></pre></td></tr></table></figure><h3 id="选项-Option"><a href="#选项-Option" class="headerlink" title="选项 (Option)"></a>选项 (Option)</h3><p>Option 是一个表示有可能包含值的容器。</p><p>Option 基本的接口是这样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Option</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isDefined</span></span>: <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">T</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getOrElse</span></span>(t: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Option 本身是泛型的，并且有两个子类： <code>Some[T]</code> 或 <code>None</code></p><p>我们看一个使用 Option 的例子：</p><p><code>Map.get</code> 使用 Option 作为其返回值，表示这个方法也许不会返回你请求的值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> numbers = <span class="type">Map</span>(<span class="string">"one"</span> -&gt; <span class="number">1</span>, <span class="string">"two"</span> -&gt; <span class="number">2</span>)</span><br><span class="line">numbers: scala.collection.immutable.<span class="type">Map</span>[java.lang.<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>(one -&gt; <span class="number">1</span>, two -&gt; <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers.get(<span class="string">"two"</span>)</span><br><span class="line">res0: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers.get(<span class="string">"three"</span>)</span><br><span class="line">res1: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">None</span></span><br></pre></td></tr></table></figure><p>现在我们的数据似乎陷在 Option 中了，我们怎样获取这个数据呢？</p><p>直觉上想到的可能是基于 <code>isDefined</code> 方法进行条件判断。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We want to multiply the number by two, otherwise return 0.</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="keyword">if</span> (res1.isDefined) &#123;</span><br><span class="line">  res1.get * <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们建议使用 <code>getOrElse</code> 或模式匹配处理这个结果。</p><p><code>getOrElse</code> 让你轻松地定义一个默认值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = res1.getOrElse(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">模式匹配能自然地配合 <span class="type">Option</span> 使用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = res1 <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(n) =&gt; n * <span class="number">2</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 Effective Scala 对使用 <a href="https://twitter.github.com/effectivescala/#Functional%20programming-Options" target="_blank" rel="noopener">Options</a> 的意见。</p><h2 id="函数组合子（Functional-Combinators）"><a href="#函数组合子（Functional-Combinators）" class="headerlink" title="函数组合子（Functional Combinators）"></a>函数组合子（Functional Combinators）</h2><p>List(1, 2, 3) map squared 对列表中的每一个元素都应用了 squared 平方函数，并返回一个新的列表 List(1, 4, 9)。我们把类似于 map 的操作称作组合子。 （如果想要更好的定义，你可以看看 Stackoverflow 上对 <a href="https://stackoverflow.com/questions/7533837/explanation-of-combinators-for-the-working-man" target="_blank" rel="noopener">组合子</a> 的说明。）他们常被用在标准的数据结构上。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code> 对列表中的每个元素应用一个函数，返回应用后的元素所组成的列表。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> numbers = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">numbers: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; numbers.map((i: <span class="type">Int</span>) =&gt; i * <span class="number">2</span>)</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>或传入一个函数 (Scala 编译器自动把我们的方法转换为函数）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">timesTwo</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = i * <span class="number">2</span></span><br><span class="line">timesTwo: (i: <span class="type">Int</span>)<span class="type">Int</span></span><br><span class="line"></span><br><span class="line">scala&gt; numbers.map(timesTwo)</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p><code>foreach</code> 很像 map，但<code>没有返回值</code>。foreach 仅用于有副作用 <code>side-effects</code> 的函数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.foreach((i: <span class="type">Int</span>) =&gt; i * <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 什么也没有返回。</span></span><br></pre></td></tr></table></figure><p>你可以尝试存储返回值，但它会是 <code>Unit</code> 类型（即 void）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> doubled = numbers.foreach((i: <span class="type">Int</span>) =&gt; i * <span class="number">2</span>)</span><br><span class="line">doubled: <span class="type">Unit</span> = ()</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code> 移除任何对传入函数计算结果为 <code>false</code> 的元素。返回一个布尔值的函数通常被称为<code>谓词函数</code> （或判定函数）。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.filter((i: <span class="type">Int</span>) =&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">isEven</span></span>(i: <span class="type">Int</span>): <span class="type">Boolean</span> = i % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">isEven: (i: <span class="type">Int</span>)<span class="type">Boolean</span></span><br><span class="line"></span><br><span class="line">scala&gt; numbers.filter(isEven)</span><br><span class="line">res2: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p><code>zip</code> 将两个列表的内容聚合到一个<code>对偶列表</code>中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).zip(<span class="type">List</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>))</span><br><span class="line">res0: <span class="type">List</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">List</span>((<span class="number">1</span>,a), (<span class="number">2</span>,b), (<span class="number">3</span>,c))</span><br></pre></td></tr></table></figure><h3 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h3><p><code>partition</code> 将使用给定的谓词函数分割列表。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> numbers = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">scala&gt; numbers.partition(_ % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">res0: (<span class="type">List</span>[<span class="type">Int</span>], <span class="type">List</span>[<span class="type">Int</span>]) = (<span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>),<span class="type">List</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find</code> 返回集合中第一个匹配谓词函数的元素。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.find((i: <span class="type">Int</span>) =&gt; i &gt; <span class="number">5</span>)</span><br><span class="line">res0: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="drop-amp-dropWhile"><a href="#drop-amp-dropWhile" class="headerlink" title="drop &amp; dropWhile"></a>drop &amp; dropWhile</h3><p><code>drop</code> 将删除<code>前 i</code> 个元素</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.drop(<span class="number">5</span>)</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><code>dropWhile</code> 将删除匹配谓词函数的<code>第一个</code>元素。例如，如果我们在 numbers 列表上使用 dropWhile 函数来去除奇数，1 将被丢弃（但 3 不会被丢弃，因为他被 2 保护了）。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.dropWhile(_ % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="foldLeft"><a href="#foldLeft" class="headerlink" title="foldLeft"></a>foldLeft</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.foldLeft(<span class="number">0</span>)((m: <span class="type">Int</span>, n: <span class="type">Int</span>) =&gt; m + n)</span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">55</span></span><br></pre></td></tr></table></figure><p>0 为初始值（记住 numbers 是 List[Int] 类型），m 作为一个累加器。在标准库的实现为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">B</span>](z: <span class="type">B</span>)(op: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> result = z</span><br><span class="line">    <span class="keyword">this</span>.seq foreach (x =&gt; result = op(result, x))</span><br><span class="line">    result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可视化观察运行过程：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.foldLeft(<span class="number">0</span>) &#123; (m: <span class="type">Int</span>, n: <span class="type">Int</span>) =&gt; println(<span class="string">"m: "</span> + m + <span class="string">" n: "</span> + n); m + n &#125;</span><br><span class="line">m: <span class="number">0</span> n: <span class="number">1</span></span><br><span class="line">m: <span class="number">1</span> n: <span class="number">2</span></span><br><span class="line">m: <span class="number">3</span> n: <span class="number">3</span></span><br><span class="line">m: <span class="number">6</span> n: <span class="number">4</span></span><br><span class="line">m: <span class="number">10</span> n: <span class="number">5</span></span><br><span class="line">m: <span class="number">15</span> n: <span class="number">6</span></span><br><span class="line">m: <span class="number">21</span> n: <span class="number">7</span></span><br><span class="line">m: <span class="number">28</span> n: <span class="number">8</span></span><br><span class="line">m: <span class="number">36</span> n: <span class="number">9</span></span><br><span class="line">m: <span class="number">45</span> n: <span class="number">10</span></span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">55</span></span><br></pre></td></tr></table></figure><h3 id="foldRight"><a href="#foldRight" class="headerlink" title="foldRight"></a>foldRight</h3><p>和 foldLeft 一样，只是运行过程相反。在标准库的实现为：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">B</span>](z: <span class="type">B</span>)(op: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> =</span><br><span class="line">    reversed.foldLeft(z)((x, y) =&gt; op(y, x))</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; numbers.foldRight(<span class="number">0</span>) &#123; (m: <span class="type">Int</span>, n: <span class="type">Int</span>) =&gt; println(<span class="string">"m: "</span> + m + <span class="string">" n: "</span> + n); m + n &#125;</span><br><span class="line">m: <span class="number">10</span> n: <span class="number">0</span></span><br><span class="line">m: <span class="number">9</span> n: <span class="number">10</span></span><br><span class="line">m: <span class="number">8</span> n: <span class="number">19</span></span><br><span class="line">m: <span class="number">7</span> n: <span class="number">27</span></span><br><span class="line">m: <span class="number">6</span> n: <span class="number">34</span></span><br><span class="line">m: <span class="number">5</span> n: <span class="number">40</span></span><br><span class="line">m: <span class="number">4</span> n: <span class="number">45</span></span><br><span class="line">m: <span class="number">3</span> n: <span class="number">49</span></span><br><span class="line">m: <span class="number">2</span> n: <span class="number">52</span></span><br><span class="line">m: <span class="number">1</span> n: <span class="number">54</span></span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">55</span></span><br></pre></td></tr></table></figure><h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><p><code>flatten</code> 将嵌套结构扁平化一个层级。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>)).flatten</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p><code>flatMap</code> 是一种常用的组合子，结合映射 <code>mapping</code> 和扁平化 <code>flattening</code>。 <code>flatMap</code> 需要一个处理嵌套列表的函数，然后将结果串连起来。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> nestedNumbers = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">nestedNumbers: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = <span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; nestedNumbers.flatMap(x =&gt; x.map(_ * <span class="number">2</span>))</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>可以把它看做是“先映射后扁平化”的快捷操作：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; nestedNumbers.map((x: <span class="type">List</span>[<span class="type">Int</span>]) =&gt; x.map(_ * <span class="number">2</span>)).flatten</span><br><span class="line">res1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>这个例子先调用 <code>map</code>，然后调用 <code>flatten</code>，这就是 <code>组合子</code> 的特征，也是这些函数的本质。</p><p>参考 Effective Scala 对 <a href="https://twitter.github.com/effectivescala/#Functional%20programming-%60flatMap%60" target="_blank" rel="noopener">flatMap</a> 的意见。</p><h2 id="扩展函数组合子"><a href="#扩展函数组合子" class="headerlink" title="扩展函数组合子"></a>扩展函数组合子</h2><p>现在我们已经学过集合上的一些函数。</p><p>我们将尝试写自己的函数组合子。</p><p>有趣的是，上面所展示的每一个函数组合子都可以用 fold 方法实现。让我们看一些例子。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ourMap</span></span>(numbers: <span class="type">List</span>[<span class="type">Int</span>], fn: <span class="type">Int</span> =&gt; <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  numbers.foldRight(<span class="type">List</span>[<span class="type">Int</span>]()) &#123; (x: <span class="type">Int</span>, xs: <span class="type">List</span>[<span class="type">Int</span>]) =&gt;</span><br><span class="line">    fn(x) :: xs <span class="comment">// 两个冒号表示普通元素与 List 的连接操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scala&gt; ourMap(numbers, timesTwo(_))</span><br><span class="line">res0: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>为什么是 <code>List[Int]()</code>？Scala 没有聪明到理解你的目的是将结果积聚在一个空的 Int 类型的列表中。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map?"></a>Map?</h3><p>所有展示的函数组合子都可以在 Map 上使用。Map 可以被看作是一个二元组的列表，所以你写的函数要处理一个键和值的二元组。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> extensions = <span class="type">Map</span>(<span class="string">"steve"</span> -&gt; <span class="number">100</span>, <span class="string">"bob"</span> -&gt; <span class="number">101</span>, <span class="string">"joe"</span> -&gt; <span class="number">201</span>)</span><br><span class="line">extensions: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>((steve,<span class="number">100</span>), (bob,<span class="number">101</span>), (joe,<span class="number">201</span>))</span><br></pre></td></tr></table></figure><p>现在筛选出电话分机号码低于 200 的条目。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; extensions.filter((namePhone: (<span class="type">String</span>, <span class="type">Int</span>)) =&gt; namePhone._2 &lt; <span class="number">200</span>)</span><br><span class="line">res0: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>((steve,<span class="number">100</span>), (bob,<span class="number">101</span>))</span><br></pre></td></tr></table></figure><p>因为参数是元组，所以你必须使用位置获取器来读取它们的键和值。呃！</p><p>幸运的是，我们其实可以使用模式匹配更优雅地提取键和值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; extensions.filter(&#123;<span class="keyword">case</span> (name, extension) =&gt; extension &lt; <span class="number">200</span>&#125;)</span><br><span class="line">res0: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>] = <span class="type">Map</span>((steve,<span class="number">100</span>), (bob,<span class="number">101</span>))</span><br></pre></td></tr></table></figure><p>为什么这个代码可以工作？为什么你可以传递一个部分模式匹配？<a href="/2019/12/01/scala-school-pattern-matching-and-functional-composition/">下一章</a>将揭晓。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本数据结构&quot;&gt;&lt;a href=&quot;#基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;基本数据结构&quot;&gt;&lt;/a&gt;基本数据结构&lt;/h2&gt;&lt;p&gt;Scala 提供了一些不错的集合。&lt;/p&gt;
&lt;p&gt;参考 Effective Scala 对怎样使用集合的观点
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Scala 课堂 - 基础（续）</title>
    <link href="https://razertory.me/2019/11/30/scala-school-bascis2/"/>
    <id>https://razertory.me/2019/11/30/scala-school-bascis2/</id>
    <published>2019-11-30T14:20:10.000Z</published>
    <updated>2020-05-04T07:02:32.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h3><p>当类或对象有一个主要用途的时候，<code>apply</code> 方法为你提供了一个很好的语法糖。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">object</span> <span class="title">FooMaker</span> </span>&#123;</span><br><span class="line">     |   <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = <span class="keyword">new</span> <span class="type">Foo</span></span><br><span class="line">     | &#125;</span><br><span class="line">defined module <span class="type">FooMaker</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> newFoo = <span class="type">FooMaker</span>()</span><br><span class="line">newFoo: <span class="type">Foo</span> = <span class="type">Foo</span>@<span class="number">5</span>b83f762</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">     |   <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>() = <span class="number">0</span></span><br><span class="line">     | &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">bar</span> </span>= <span class="keyword">new</span> <span class="type">Bar</span></span><br><span class="line">bar: <span class="type">Bar</span> = <span class="type">Bar</span>@<span class="number">47711479</span></span><br><span class="line"></span><br><span class="line">scala&gt; bar()</span><br><span class="line">res8: <span class="type">Int</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在这里，我们实例化对象看起来像是在调用一个方法。以后会有更多介绍！</p><h3 id="单例对象-object"><a href="#单例对象-object" class="headerlink" title="单例对象 (object)"></a>单例对象 (object)</h3><p>单例对象用于持有一个类的唯一实例。通常用于 <a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">工厂模式</a>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">currentCount</span></span>(): <span class="type">Long</span> = &#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样使用：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="type">Timer</span>.currentCount()</span><br><span class="line">res0: <span class="type">Long</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>单例对象可以和类具有相同的名称，此时该对象也被称为<code>伴生对象</code>。我们通常将伴生对象作为工厂使用。</p><p>下面是一个简单的例子，可以不需要使用 <code>new</code> 来创建一个实例了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>(<span class="params">foo: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(foo: <span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Bar</span>(foo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数即对象"><a href="#函数即对象" class="headerlink" title="函数即对象"></a>函数即对象</h3><p> Scala 中，我们经常谈论对象的函数式编程。这是什么意思？到底什么是函数呢？</p><p>函数是一些特质的集合。具体来说，具有一个参数的函数是 Function1 trait 的一个实例。这个 trait 定义了 <code>apply</code> 语法糖，让你调用一个对象时就像你在调用一个函数。（关于 Function1 trait 在 Scala API doc 中有详细介绍  <a href="https://www.scala-lang.org/api/2.7.5/scala/Function1.html" target="_blank" rel="noopener">https://www.scala-lang.org/api/2.7.5/scala/Function1.html</a> )</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">object</span> <span class="title">addOne</span> <span class="keyword">extends</span> <span class="title">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] </span>&#123;</span><br><span class="line">     |   <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(m: <span class="type">Int</span>): <span class="type">Int</span> = m + <span class="number">1</span></span><br><span class="line">     | &#125;</span><br><span class="line">defined module addOne</span><br><span class="line"></span><br><span class="line">scala&gt; addOne(<span class="number">1</span>)</span><br><span class="line">res2: <span class="type">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这个 Function trait 集合下标从 0 开始一直到 22。为什么是 22？这是一个主观的魔幻数字 (magic number)。我从来没有使用过多于 22 个参数的函数，所以这个数字似乎是合理的。（在 Scala )</p><p><code>apply</code> 语法糖有助于统一对象和函数式编程的二重性。你可以传递类，并把它们当做函数使用，而函数本质上是类的实例。</p><p>这是否意味着，当你在类中定义一个方法时，得到的实际上是一个 Function *的实例？不是的，在类中定义的方法是方法而不是函数。在 repl 中独立定义的方法是 Function *的实例。</p><p>类也可以扩展 Function，这些类的实例可以使用 <code>()</code> 调用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">AddOne</span> <span class="keyword">extends</span> <span class="title">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] </span>&#123;</span><br><span class="line">     |   <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(m: <span class="type">Int</span>): <span class="type">Int</span> = m + <span class="number">1</span></span><br><span class="line">     | &#125;</span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">AddOne</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">plusOne</span> </span>= <span class="keyword">new</span> <span class="type">AddOne</span>()</span><br><span class="line">plusOne: <span class="type">AddOne</span> = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; plusOne(<span class="number">1</span>)</span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以使用更直观快捷的 <code>extends (Int =&gt; Int)</code> 代替 extends Function1[Int, Int]</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddOne</span> <span class="keyword">extends</span> (<span class="params"><span class="type">Int</span> =&gt; <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(m: <span class="type">Int</span>): <span class="type">Int</span> = m + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包-package"><a href="#包-package" class="headerlink" title="包 (package)"></a>包 (package)</h3><p>你可以将代码组织在包里。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.twitter.example</span><br></pre></td></tr></table></figure><p>在文件头部定义包，会将文件中所有的代码声明在那个包中。</p><p>值和函数不能在类或单例对象之外定义。单例对象是组织静态函数 <code>static function</code> 的有效工具。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.twitter.example</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">colorHolder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">BLUE</span> = <span class="string">"Blue"</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">RED</span> = <span class="string">"Red"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在你可以直接访问这些成员</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"the color is: "</span> + com.twitter.example.colorHolder.<span class="type">BLUE</span>)</span><br></pre></td></tr></table></figure><p>注意在你定义这个对象时 Scala 解释器的返回：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">object</span> <span class="title">colorHolder</span> </span>&#123;</span><br><span class="line">     |   <span class="keyword">val</span> <span class="type">Blue</span> = <span class="string">"Blue"</span></span><br><span class="line">     |   <span class="keyword">val</span> <span class="type">Red</span> = <span class="string">"Red"</span></span><br><span class="line">     | &#125;</span><br><span class="line">defined module colorHolder</span><br></pre></td></tr></table></figure><p>这暗示了 Scala 的设计者是把对象作为 Scala 的<a href="https://www.scala-lang.org/docu/files/skeb-slides.pdf" target="_blank" rel="noopener">模块系统</a>的一部分进行设计的。</p><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>这是 Scala 中最有用的部分之一。</p><p>匹配值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> times = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">times <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"some other number"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用守卫进行匹配</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">times <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> i <span class="keyword">if</span> i == <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">  <span class="keyword">case</span> i <span class="keyword">if</span> i == <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"some other number"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们是怎样获取变量 <code>i</code> 的值的。</p><p>在最后一行指令中的<code>_</code>是一个通配符；它保证了我们可以处理所有的情况。 (注意第一章提到的 <code>_</code> 在不同上下文中有不同含义)<br>否则当传进一个不能被匹配的数字的时候，你将获得一个运行时错误。我们以后会继续讨论这个话题的。</p><p>参考 Effective Scala 对<a href="https://twitter.github.com/effectivescala/#Functional%20programming-Pattern%20matching" target="_blank" rel="noopener">什么时候使用模式匹配</a>和<a href="https://twitter.github.com/effectivescala/#Formatting-Pattern%20matching" target="_blank" rel="noopener">模式匹配格式化的建议</a>。A Tour of Scala 也描述了<a href="https://www.scala-lang.org/node/120" target="_blank" rel="noopener">模式匹配</a></p><h3 id="匹配类型"><a href="#匹配类型" class="headerlink" title="匹配类型"></a>匹配类型</h3><p>你可以使用 <code>match</code> 来分别处理不同类型的值。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bigger</span></span>(o: <span class="type">Any</span>): <span class="type">Any</span> = &#123;</span><br><span class="line">  o <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> <span class="keyword">if</span> i &lt; <span class="number">0</span> =&gt; i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> d: <span class="type">Double</span> <span class="keyword">if</span> d &lt; <span class="number">0.0</span> =&gt; d - <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">case</span> d: <span class="type">Double</span> =&gt; d + <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">case</span> text: <span class="type">String</span> =&gt; text + <span class="string">"s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配类成员"><a href="#匹配类成员" class="headerlink" title="匹配类成员"></a>匹配类成员</h3><p>还记得我们之前的计算器吗。</p><p>让我们通过类型对它们进行分类。</p><p>一开始会很痛苦。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcType</span></span>(calc: <span class="type">Calculator</span>) = calc <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> _ <span class="keyword">if</span> calc.brand == <span class="string">"HP"</span> &amp;&amp; calc.model == <span class="string">"20B"</span> =&gt; <span class="string">"financial"</span></span><br><span class="line">  <span class="keyword">case</span> _ <span class="keyword">if</span> calc.brand == <span class="string">"HP"</span> &amp;&amp; calc.model == <span class="string">"48G"</span> =&gt; <span class="string">"scientific"</span></span><br><span class="line">  <span class="keyword">case</span> _ <span class="keyword">if</span> calc.brand == <span class="string">"HP"</span> &amp;&amp; calc.model == <span class="string">"30B"</span> =&gt; <span class="string">"business"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"unknown"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(⊙o⊙) 哦，太痛苦了。幸好 Scala 提供了一些应对这种情况的有效工具。</p><p><strong>样本类 (Case Classes)</strong><br>使用样本类可以方便提前准备好需要进行匹配类内容，并且不用 new 关键字就可以创建它们。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>(<span class="params">brand: <span class="type">String</span>, model: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">defined</span> <span class="title">class</span> <span class="title">Calculator</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">hp20b</span> </span>= <span class="type">Calculator</span>(<span class="string">"HP"</span>, <span class="string">"20b"</span>)</span><br><span class="line">hp20b: <span class="type">Calculator</span> = <span class="type">Calculator</span>(hp,<span class="number">20</span>b)</span><br></pre></td></tr></table></figure><p>样本类基于构造函数的参数，自动地实现了相等性和易读的 toString 方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> hp20b = <span class="type">Calculator</span>(<span class="string">"HP"</span>, <span class="string">"20b"</span>)</span><br><span class="line">hp20b: <span class="type">Calculator</span> = <span class="type">Calculator</span>(hp,<span class="number">20</span>b)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> hp20B = <span class="type">Calculator</span>(<span class="string">"HP"</span>, <span class="string">"20b"</span>)</span><br><span class="line">hp20B: <span class="type">Calculator</span> = <span class="type">Calculator</span>(hp,<span class="number">20</span>b)</span><br><span class="line"></span><br><span class="line">scala&gt; hp20b == hp20B</span><br><span class="line">res6: <span class="type">Boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>样本类也可以像普通类那样拥有方法。</p><p>使用样本类进行模式匹配<br>样本类就是被设计用在模式匹配中的。让我们简化之前的计算器分类器的例子。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hp20b = <span class="type">Calculator</span>(<span class="string">"HP"</span>, <span class="string">"20B"</span>)</span><br><span class="line"><span class="keyword">val</span> hp30b = <span class="type">Calculator</span>(<span class="string">"HP"</span>, <span class="string">"30B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcType</span></span>(calc: <span class="type">Calculator</span>) = calc <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Calculator</span>(<span class="string">"HP"</span>, <span class="string">"20B"</span>) =&gt; <span class="string">"financial"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Calculator</span>(<span class="string">"HP"</span>, <span class="string">"48G"</span>) =&gt; <span class="string">"scientific"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Calculator</span>(<span class="string">"HP"</span>, <span class="string">"30B"</span>) =&gt; <span class="string">"business"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Calculator</span>(ourBrand, ourModel) =&gt; <span class="string">"Calculator: %s %s is of unknown type"</span>.format(ourBrand, ourModel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一句也可以这样写</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Calculator</span>(_, _) =&gt; <span class="string">"Calculator of unknown type"</span></span><br></pre></td></tr></table></figure><p>或者我们完全可以不将匹配对象指定为 Calculator 类型</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">"Calculator of unknown type"</span></span><br></pre></td></tr></table></figure><p>或者我们也可以将匹配的值重新命名。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> c<span class="meta">@Calculator</span>(_, _) =&gt; <span class="string">"Calculator: %s of unknown type"</span>.format(c)</span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>Scala 中的异常可以在 <code>try-catch-finally</code> 语法中通过模式匹配使用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  remoteCalculatorService.add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">ServerIsDownException</span> =&gt; log.error(e, <span class="string">"the remote calculator service is unavailable. should have kept your trusty HP."</span>)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  remoteCalculatorService.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// try 也是面向表达式的</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Int</span> = <span class="keyword">try</span> &#123;</span><br><span class="line">  remoteCalculatorService.add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">ServerIsDownException</span> =&gt; &#123;</span><br><span class="line">    log.error(e, <span class="string">"the remote calculator service is unavailable. should have kept your trusty HP."</span>)</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  remoteCalculatorService.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这并不是一个完美编程风格的展示，而只是一个例子，用来说明 <code>try-catch-finally</code> 和 Scala 中其他大部分事物一样是表达式。</p><p>当一个异常被捕获处理了，<code>finally</code> 块将被调用；它不是表达式的一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;apply-方法&quot;&gt;&lt;a href=&quot;#apply-方法&quot; class=&quot;headerlink&quot; title=&quot;apply 方法&quot;&gt;&lt;/a&gt;apply 方法&lt;/h3&gt;&lt;p&gt;当类或对象有一个主要用途的时候，&lt;code&gt;apply&lt;/code&gt; 方法为你提供了一个很好
      
    
    </summary>
    
    
  </entry>
  
</feed>
