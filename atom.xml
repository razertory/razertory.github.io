<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Razertory 的技术博客</title>
  
  <subtitle>一曲肝肠断，天涯何处觅知音</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://razertory.me/"/>
  <updated>2020-04-12T07:12:39.314Z</updated>
  <id>https://razertory.me/</id>
  
  <author>
    <name>Razertory</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「Linux 内核」系统调用</title>
    <link href="https://razertory.me/2020/04/12/linux-kernel-system-call/"/>
    <id>https://razertory.me/2020/04/12/linux-kernel-system-call/</id>
    <published>2020-04-12T05:50:04.000Z</published>
    <updated>2020-04-12T07:12:39.314Z</updated>
    
    <content type="html"><![CDATA[<p>内核内存空间在操作系统中是受保护的。通常情况下，一个普通程序执行在用户空间。当需要与内核通信的时候，比如写文件到磁盘，就需要进行<strong>系统调用</strong>。</p><p>有趣的是，内核原生提供的系统调用很少(参考<a href="http://asm.sourceforge.net/syscall.html" target="_blank" rel="noopener">List of Linux/i386 system calls</a>)。当我们需要系统调用的时候，实际上是在调用调用的上一层 API。这一层 API 封装了各种系统调用（通常就是操作系统内置的 C 库）。现阶段，这一层 API 的标准来自于 IEEE ，名为 POSIX（Portable Operating System Interface）。这么做的原因是 unix 倡导的 <em>提供机制，而不是提供策略</em>。意思是提供有限的，但可以很好组合的工具、方法，在此基础上实现各种功能。</p><p>例如，</p><p><code>get_pid()</code> 在内核中的被定义为 <code>sys_getpid()</code><br><code>bar()</code> 在内核中被定义为 <code>sys_bar()</code></p><p>一个用户空间的程序，要做系统调用，具体的过程为</p><ul><li>陷入内核</li><li>传递系统调用编号和参数</li><li>执行系统调用</li><li>将系统调用的返回值带给用户空间</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;内核内存空间在操作系统中是受保护的。通常情况下，一个普通程序执行在用户空间。当需要与内核通信的时候，比如写文件到磁盘，就需要进行&lt;strong&gt;系统调用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有趣的是，内核原生提供的系统调用很少(参考&lt;a href=&quot;http://asm.so
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://razertory.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>「Linux 内核」进程管理</title>
    <link href="https://razertory.me/2020/04/11/linux-kernel-process/"/>
    <id>https://razertory.me/2020/04/11/linux-kernel-process/</id>
    <published>2020-04-11T10:15:42.000Z</published>
    <updated>2020-04-11T11:54:05.665Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>进程是处于执行期的程序以及相关资源的总称。比如打开的文件、挂起的信号、内核内部数据等等。在 linux 源码中，一个进程的相关信息维护在 task_struct <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L632" target="_blank" rel="noopener">task_struct</a>的结构体中。这里面包含了进程的状态(pid，运行状态)、相关资源、以及相关进程（子进程、父进程）信息。内核会维护一个双向链表，每个链表的节点指向对应的 task_struct。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ul><li>TASK_RUNNING: 可执行的；等待执行的</li><li>TASK_INTERRUPTIBLE: 可中断的; 比如被阻塞、或者在 sleep</li><li>TASK_UNINTERRUPTIBLE: 不可中断的; 对外界的信号不做出响应</li><li>EXIT_ZOMBIE: 主动退出；还没有完全释放资源</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fgy1gdq0dnlo0cg20fw09b0sw.gif" alt="进程状态图" title>                </div>                <div class="image-caption">进程状态图</div>            </figure><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>在进程被 fork 出来之后 task_struct 会有自己的 pid 和父进程的 pid。但一些必要的系统资源并不会拷贝过来，而是当需要写入的时候再做(copy-on-write)。进程调用 exit() 结束, 部分资源会释放，同时调用 exit_notify() 向父进程发信号。若父进程及时响应，此时释放所有的资源；否则认为此时的这个进程是僵尸进程。同理，如果父进程先于子进程退出，子进程就会成为孤儿进程。内核会将这类进程归给 pid 为 1 的进程。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是一种特殊的进程（强调只是 linux）同一个进程的 N 个线程只是 N 个共享同一块资源的<br>task_struct。比如进程创建的时候会依赖 clone 方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>而线程的创建就是传递来一些参数来指明被共享的资源，这个设计现在看起来也是非常优雅的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h4&gt;&lt;p&gt;进程是处于执行期的程序以及相关资源的总称。比如打开的文件、挂起的信号、内核内部数据等等。在 linux 源码中，一个进程的相关信息维护在 t
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://razertory.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Scala 函数式编程设计</title>
    <link href="https://razertory.me/2020/02/20/functional-program-design-in-scala/"/>
    <id>https://razertory.me/2020/02/20/functional-program-design-in-scala/</id>
    <published>2020-02-20T15:53:05.000Z</published>
    <updated>2020-03-28T13:02:10.018Z</updated>
    
    <content type="html"><![CDATA[<p>在这个 2020 年初的特殊时期。</p><p>Scala 是一门现代化，多范式的 JVM 语言。</p><p>传送门（可能需要🚀)</p><ul><li><a href="https://www.coursera.org/learn/progfun2" target="_blank" rel="noopener">Functional Program Design in Scala on Coursera</a></li><li><a href="https://www.coursera.org/account/accomplishments/certificate/BP5FRUVSFPN8" target="_blank" rel="noopener">没什么用的 certificate</a></li></ul><hr><h2 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h2><h3 id="case-class-和模式匹配"><a href="#case-class-和模式匹配" class="headerlink" title="case class 和模式匹配"></a>case class 和模式匹配</h3><p>用 Scala 来表示 JSON 对象可以这样</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSON</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JSeq</span> (<span class="params">elems: <span class="type">List</span>[<span class="type">JSON</span>]</span>) <span class="keyword">extends</span> <span class="title">JSON</span>  <span class="title">//</span> <span class="title">JSON</span> <span class="title">的数组</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JObj</span> (<span class="params">bindings: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">JSON</span>]</span>) <span class="keyword">extends</span> <span class="title">JSON</span> <span class="title">//</span> <span class="title">JSON</span> <span class="title">对象</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JNum</span> (<span class="params">num: <span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">JSON</span> <span class="title">//</span> <span class="title">数字类型</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JStr</span> (<span class="params">str: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">JSON</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">JBool</span>(<span class="params">b: <span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">JSON</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">JNull</span> <span class="keyword">extends</span> <span class="title">JSON</span> <span class="title">//</span> <span class="title">空</span></span></span><br></pre></td></tr></table></figure><p>所以，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"firstName"</span> : <span class="string">"John"</span>,</span><br><span class="line">    <span class="attr">"lastName"</span> : <span class="string">"Smith"</span>,</span><br><span class="line">    <span class="attr">"address"</span> : &#123;</span><br><span class="line">        <span class="attr">"streetAddress"</span> : <span class="string">"21 2 nd Street"</span>,</span><br><span class="line">        <span class="attr">"state"</span> : <span class="string">"NY"</span>,</span><br><span class="line">        <span class="attr">"postalCode"</span>: <span class="number">10021</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"phoneNumbers"</span>: [</span><br><span class="line">        &#123;<span class="attr">"type"</span> : <span class="string">"home"</span>,<span class="attr">"number "</span>: <span class="string">"212 555 -1234"</span>&#125; ,</span><br><span class="line">        &#123;<span class="attr">"type"</span> : <span class="string">"fax"</span>,<span class="attr">"number "</span>: <span class="string">"646 555 -4567"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以表示为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> data = <span class="type">JObj</span>(<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"firstName"</span> -&gt; <span class="type">JStr</span>(<span class="string">"John"</span>),</span><br><span class="line">    <span class="string">"lastName"</span> -&gt; <span class="type">JStr</span>(<span class="string">"Smith"</span>),</span><br><span class="line">    <span class="string">"address"</span> -&gt; <span class="type">JObj</span>(<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"streetAddress"</span> -&gt; <span class="type">JStr</span>(<span class="string">"21 2nd Street"</span>),</span><br><span class="line">    <span class="string">"state"</span> -&gt; <span class="type">JStr</span>(<span class="string">"NY"</span>),</span><br><span class="line">    <span class="string">"postalCode"</span> -&gt; <span class="type">JNum</span>(<span class="number">10021</span>)</span><br><span class="line">)),</span><br><span class="line"><span class="string">"phoneNumbers"</span> -&gt; <span class="type">JSeq</span>(<span class="type">List</span>(</span><br><span class="line">    <span class="type">JObj</span>(<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"type"</span> -&gt; <span class="type">JStr</span>(<span class="string">"home"</span>), <span class="string">"number"</span> -&gt; <span class="type">JStr</span>(<span class="string">"212 555-1234"</span>)</span><br><span class="line">)),</span><br><span class="line"><span class="type">JObj</span>(<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"type"</span> -&gt; <span class="type">JStr</span>(<span class="string">"fax"</span>), <span class="string">"number"</span> -&gt; <span class="type">JStr</span>(<span class="string">"646 555-4567"</span>)</span><br><span class="line">)) )) ))</span><br></pre></td></tr></table></figure><p>比如说我要实现一个打印 JSON 对象的方法，就可以</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span></span>(json: <span class="type">JSON</span>): <span class="type">String</span> = json <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSeq</span>(elems) =&gt;</span><br><span class="line">    <span class="string">"["</span> + (elems map show mkString <span class="string">", "</span>) + <span class="string">"]"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JObj</span>(bindings) =&gt;</span><br><span class="line">    <span class="keyword">val</span> assocs = bindings map &#123;</span><br><span class="line">        <span class="keyword">case</span> (key, value) =&gt; <span class="string">"\""</span> + key + <span class="string">"\": "</span> + show(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">"&#123;"</span> + (assocs mkString <span class="string">", "</span>) + <span class="string">"&#125;"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JNum</span>(num) =&gt; num.toString</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JStr</span>(str) =&gt; '\<span class="string">"' + str + '\"'</span></span><br><span class="line"><span class="string">    case JBool(b) =&gt; b.toString</span></span><br><span class="line"><span class="string">    case JNull =&gt; "</span><span class="string">null"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上述的 show(data) 就输出</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res1: <span class="type">String</span> = &#123;<span class="string">"firstName"</span>: <span class="string">"John"</span>, <span class="string">"lastName"</span>: <span class="string">"Smith"</span>, <span class="string">"address"</span>: &#123;<span class="string">"streetAddress"</span>: <span class="string">"21 2nd Street"</span>, <span class="string">"state"</span>: <span class="string">"NY"</span>, <span class="string">"postalCode"</span>: <span class="number">10021.0</span>&#125;, <span class="string">"phoneNumbers"</span>: [&#123;<span class="string">"type"</span>: <span class="string">"home"</span>, <span class="string">"number"</span>: <span class="string">"212 555-1234"</span>&#125;, &#123;<span class="string">"type"</span>: <span class="string">"fax"</span>, <span class="string">"number"</span>: <span class="string">"646 555-4567"</span>&#125;]&#125;</span><br></pre></td></tr></table></figure><p>第 6 行代码里面 map 传入的函数是，我们知道，在这里 map 函数的签名是 <code>def map[B](f: (A) =&gt; B): List[B]</code><br>那么第六行的 <code>f</code> 就是 <code>case (key, value) =&gt; &quot;\&quot;&quot; + key + &quot;\&quot;: &quot; + show(value)</code>。 这个函数如果单独拎出来，其实就是</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f: (<span class="type">String</span>, <span class="type">JSON</span>) =&gt; <span class="type">String</span> = &#123; <span class="keyword">case</span> (key, value) =&gt; key + ”: ” + value &#125; <span class="comment">// 注意看 JObj 定义</span></span><br></pre></td></tr></table></figure><p>所以用 case class 最方便的地方在于<strong>模式匹配中的 decompose</strong></p><h3 id="函数即对象"><a href="#函数即对象" class="headerlink" title="函数即对象"></a>函数即对象</h3><p>任何情况下，函数 <code>A =&gt; B</code> 其实就是</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala.<span class="type">Function1</span>[<span class="type">A</span>, <span class="type">B</span>]</span><br></pre></td></tr></table></figure><p>的简写。</p><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><p>根据 Function1 的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">A</span>, +<span class="type">R</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">A</span>): <span class="type">R</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f1: <span class="type">Int</span> =&gt; <span class="type">Int</span> = (x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> f2 = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>) = x + <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>f1 和 f2 等价。</p><h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><p>对于偏函数 PartialFunction 定义为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PartialFunction</span>[-<span class="type">A</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">Function1</span>[-<span class="type">A</span>, +<span class="type">R</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">A</span>): <span class="type">R</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">A</span>): <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f1: <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] = &#123; <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="string">"pong"</span> &#125;</span><br><span class="line"><span class="keyword">val</span> f2 = <span class="keyword">new</span> <span class="type">PartialFunction</span>[<span class="type">String</span>, <span class="type">String</span>] &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">String</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="string">"pong"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isDefinedAt</span></span>(x: <span class="type">String</span>) = x <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ping"</span> =&gt; <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f1 和 f2 等价。</p><p>ps: 以上，「等价」的意思是两个函数只要输入相同，输出一定相同。</p><h2 id="W2"><a href="#W2" class="headerlink" title="W2"></a>W2</h2><h3 id="LazyList"><a href="#LazyList" class="headerlink" title="LazyList"></a>LazyList</h3><p>下面代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x: <span class="type">Int</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  println(x + <span class="string">" "</span>)</span><br><span class="line">  x % <span class="number">11</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> v1 = (<span class="number">1</span> to <span class="number">100000</span>).filter(f)(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> v2 = (<span class="number">1</span> to <span class="number">100000</span>).to(<span class="type">LazyList</span>).filter(f)(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>v1 和 v2 等价。计算 v1 的时候会打印 <code>1 2 3...9999 100000</code>, 而计算 v2 的时候打印 <code>1 2 3 ... 21 22</code>。这是因为对于 v2，<code>(1 to 100000).to(LazyList)</code> 产生的是 <code>scala.collection.immutable.LazyList</code>。其中官方文档对其有个简单的描述</p><blockquote><p>This class implements an immutable linked list that evaluates elements in order and only when needed</p></blockquote><p>也就是当 LazyList 里面的元素被需要的时候，才会进行有序计算，并且计算会终止知道所需的元素计算结束。这也就是为什么会有上述的输出了。</p><h3 id="惰性求值-Lazy-Evaluation"><a href="#惰性求值-Lazy-Evaluation" class="headerlink" title="惰性求值 Lazy Evaluation"></a>惰性求值 Lazy Evaluation</h3><p>在 Scala 里面，Lazy 意味着两点</p><ul><li><strong>尽量延后求值计算</strong></li><li><strong>只计算一次</strong></li></ul><p>例如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">val</span> x = &#123; print(”x”); <span class="number">1</span> &#125;</span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> y = &#123; print(”y”); <span class="number">2</span> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">z</span> </span>= &#123; print(”z”); <span class="number">3</span> &#125;</span><br><span class="line">  z + y + x + z + y + x <span class="comment">// last line</span></span><br><span class="line">&#125;</span><br><span class="line">expr</span><br></pre></td></tr></table></figure><p>这样的输出为 <code>xzyz</code></p><h3 id="Infinite-Sequences"><a href="#Infinite-Sequences" class="headerlink" title="Infinite Sequences"></a>Infinite Sequences</h3><p>利用 LazyList 的特性，可以构造出无限序列。比如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">from</span></span>(n: <span class="type">Int</span>): <span class="type">LazyList</span>[<span class="type">Int</span>] = n #:: from(n + <span class="number">1</span>) <span class="comment">// 无限序列</span></span><br><span class="line">from: (n: <span class="type">Int</span>)<span class="type">LazyList</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> natures = from(<span class="number">0</span>) <span class="comment">// 自然数</span></span><br><span class="line">natures: <span class="type">LazyList</span>[<span class="type">Int</span>] = <span class="type">LazyList</span>(&lt;not computed&gt;)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> hundreds = natures.filter(_ % <span class="number">100</span> == <span class="number">0</span>)</span><br><span class="line">hundreds: scala.collection.immutable.<span class="type">LazyList</span>[<span class="type">Int</span>] = <span class="type">LazyList</span>(&lt;not computed&gt;)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> fourHundred = hundreds(<span class="number">4</span>) <span class="comment">// 计算</span></span><br><span class="line">fourHundred: <span class="type">Int</span> = <span class="number">400</span></span><br></pre></td></tr></table></figure><p><strong>埃拉托斯特尼筛法</strong></p><blockquote><p>埃拉托斯特尼筛法是列出所有小素数最有效的方法之一，其名字来自于古希腊数学家埃拉托斯特尼，并且被描述在另一位古希腊数学家尼科马库斯所著的《算术入门》中。-<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>用 LazyList 实现会非常简单，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">from</span></span>(n: <span class="type">Int</span>): <span class="type">LazyList</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  n #:: from(n + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sieve</span></span>(s: <span class="type">LazyList</span>[<span class="type">Int</span>]): <span class="type">LazyList</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">  s.head #:: sieve(s.tail.filter(_ % s.head != <span class="number">0</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primeNumber</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    sieve(from(<span class="number">2</span>))(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> n = sieve(from(<span class="number">2</span>))(<span class="number">100</span>) <span class="comment">// 输出 547</span></span><br></pre></td></tr></table></figure><h3 id="题目：倒水问题"><a href="#题目：倒水问题" class="headerlink" title="题目：倒水问题"></a>题目：倒水问题</h3><p>给几个知道容量，但是没有刻度的杯子，有个可以取之不尽的水源用来给杯子装满水和将杯子的水全部倒出。我们需要做的就是盛出给定容量的水。我们能做的操作有三个</p><ul><li>empty 清空</li><li>fill 放满水</li><li>pour(a, b) 把 a 的水全部往 b 倒直至 b 杯满了或者 a 杯没水了</li></ul><p>现在需要找到取得容量为 N 的水时，需要的操作。</p><p>附：1. <a href="https://github.com/razertory/scala-code-lab/blob/master/src/main/scala/scalaschool/WaterPouring.scala" target="_blank" rel="noopener">Scala 完整代码</a> 2. <a href="https://www.youtube.com/watch?v=q6M_pco_5Vo" target="_blank" rel="noopener">python 解法</a></p><h2 id="W3"><a href="#W3" class="headerlink" title="W3"></a>W3</h2><blockquote><p>下面会用 Scala 进行加法器模拟。对于计算机中，两个数如何相加，可以提前阅读 <a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E6%B3%95%E5%99%A8" target="_blank" rel="noopener">维基百科-加法器</a>，最好能够做一下 <a href="/2019/11/11/add-by-bit/">位运算实现加法</a>。</p></blockquote><p>通过以上内容，我们需要知道的最重要的点在于：两个一位二进制数相加，将会产生两个输出，其中一个是当前位相加的值 S，另一个是相加后的进位信息 C。其中 S 可以用<em>异或门</em>，进位可以用<em>与门</em>。两个半加器用<em>或</em>门组合为一个全加器。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fgy1gc6mm6fcccj21fo0rgh3a.jpg" alt="异或的操作通过三种门的组合实现" title>                </div>                <div class="image-caption">异或的操作通过三种门的组合实现</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fgy1gc6mmvhps1j20tq0ja10b.jpg" alt="两个用与门组合的半加器构成一个全加器" title>                </div>                <div class="image-caption">两个用与门组合的半加器构成一个全加器</div>            </figure><p>根据上图，我们至少需要实现的是</p><ul><li><p>电线：用来传导信号，信号可以用 boolean 类型表示 0 和 1</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wire</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> sigVal = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getSignal</span></span>: <span class="type">Boolean</span> = sigVal</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setSignal</span></span>(s: <span class="type">Boolean</span>): <span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">if</span> (s != sigVal) &#123;</span><br><span class="line">        sigVal = s</span><br><span class="line">        actions foreach(_())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与门：输入两个电信号，输出 &amp; 对应的信号</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">andGate</span></span>(in1: <span class="type">Wire</span>, in2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = ???</span><br></pre></td></tr></table></figure><ul><li>或门：输入两个电信号，输出 | 对应的信号</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">orGate</span></span>(in1: <span class="type">Wire</span>, in2: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = ???</span><br></pre></td></tr></table></figure><ul><li>逆变器：输入电信号，输出 ! 对应的信号</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inverter</span></span>(in: <span class="type">Wire</span>, output: <span class="type">Wire</span>): <span class="type">Unit</span> = ???</span><br></pre></td></tr></table></figure><p>在此基础上，实现出半加器和全加器</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">halfAdder</span></span>(a: <span class="type">Wire</span>, b: <span class="type">Wire</span>, s: <span class="type">Wire</span>, c: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> d = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  <span class="keyword">val</span> e = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  orGate(a, b, d)</span><br><span class="line">  andGate(a, b, c)</span><br><span class="line">  inverter(c, e)</span><br><span class="line">  andGate(d, e, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fullAdder</span></span>(a: <span class="type">Wire</span>, b: <span class="type">Wire</span>, cin: <span class="type">Wire</span>, sum: <span class="type">Wire</span>, cout: <span class="type">Wire</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> s = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  <span class="keyword">val</span> c1 = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  <span class="keyword">val</span> c2 = <span class="keyword">new</span> <span class="type">Wire</span></span><br><span class="line">  halfAdder(b, cin, s, c1)</span><br><span class="line">  halfAdder(a, s, sum, c2)</span><br><span class="line">  orGate(c1, c2, cout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了全加器后。加入模拟信号的输入输出即可，完整代码 <a href="https://github.com/razertory/scala-code-lab/blob/master/src/main/scala/scalaschool/DigitalCircuitSimulator.scala" target="_blank" rel="noopener">模拟加法器</a></p><h2 id="W4"><a href="#W4" class="headerlink" title="W4"></a>W4</h2><h3 id="Functional-Reactive-Programming-FRP"><a href="#Functional-Reactive-Programming-FRP" class="headerlink" title="Functional Reactive Programming (FRP)"></a>Functional Reactive Programming (FRP)</h3><p>在 MVC 模型中，FRP 可以让 model 在产生变化的同时 view 自动变化。这样的模型一般也就是 pub-sub 模型或者叫观察者模型 (observers)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subscriber1   subscribe     ___________</span><br><span class="line">Subscriber2  ------------&gt; |          |</span><br><span class="line">Subscriber3                |Publisher |</span><br><span class="line">Subscriber4  &lt;------------ |          |</span><br><span class="line">Subscriber5    publish     |__________|</span><br></pre></td></tr></table></figure><p>通用的说比如 <code>a = f(b)</code> 里面。当 b 在发生变化的时候 a 也会跟着变。实现这一点，<br>可以把「变化」归化为「event」，而自动检查这些「event」的东西叫做 Signal。在 Scala 里面通常把这样的 Signal 实现为一个类型，通过 apply() 给其赋值。比如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="type">Signal</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> v = s() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>同时，为了给 Signal 再次赋值，可以扩展新增一个 update 方法。比如 <code>s.update(5)</code>，顺带可以写成 <code>s() = 5</code>。这样的话，实现一个扩展了 Signal 名为 <code>Var</code> 的类型，让其拥有 <code>update</code> 方法。</p><p>在这样的条件下，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">val</span> num = <span class="type">Var</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> twice = <span class="type">Signal</span>(num() * <span class="number">2</span>)</span><br><span class="line">num() = <span class="number">2</span></span><br><span class="line"><span class="comment">// (2)</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="type">Var</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> twice = <span class="type">Signal</span>(num() * <span class="number">2</span>)</span><br><span class="line">num = <span class="type">Var</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>(1) 里面的 twice 变为 4，（2）里面的 twice 还是 2。上述体现的 FRP 里面，num 是 <em>publisher</em>，twice 是 <em>subscriber</em>。num 产生了 event，twice 接受这样的 event。并且所有的变量本身都是 <em>immutable</em>。</p><h3 id="实现-FRP"><a href="#实现-FRP" class="headerlink" title="实现 FRP"></a>实现 FRP</h3><h4 id="Var-和-Signal"><a href="#Var-和-Signal" class="headerlink" title="Var 和 Signal"></a>Var 和 Signal</h4><p>我们知道 Signal 和 Var 应该是这样</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signal</span>[<span class="type">T</span>](<span class="params">expr: =&gt; <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">T</span> = ???</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Signal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](expr: =&gt; <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">Signal</span>(expr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Var</span>[<span class="type">T</span>](<span class="params">expr: =&gt; <span class="type">T</span></span>) <span class="keyword">extends</span> <span class="title">Signal</span>[<span class="type">T</span>](<span class="params">expr</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span></span>(expr: =&gt; <span class="type">T</span>): <span class="type">Unit</span> = ???</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Var</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](expr: =&gt; <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">Var</span>(expr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="维护订阅关系"><a href="#维护订阅关系" class="headerlink" title="维护订阅关系"></a>维护订阅关系</h3><p>有了这些方法，就可以做到赋值和再次赋值。还需要的是，当一个 publisher 产生了 event 的时候，如何自动通知到对应的 subscriber，并且让其重新计算（re-evaluate）。</p><p>例如，s 是 Var 类型，并且进入到了表达式 expr 里，形如 <code>expr s</code>，那么当表达式 <code>expr s</code>，作为参数传递给了某个 Signal 形如 <code>val t = Signal(expr s)</code> 的时候。就需要给 s 维护一个 subscriber。同理，当有多个 subscribers 的时候就给 s 维护一个 subscriber 的集合。比如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val set = Set()</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="type">Var</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发的条件就是 class Var 的 apply 方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发：set += Signal(num() * 2)</span></span><br><span class="line"><span class="keyword">val</span> double = <span class="type">Signal</span>(num() * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发：set += Signal(num() * 3)</span></span><br><span class="line"><span class="keyword">val</span> tiple = <span class="type">Signal</span>(num() * <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>触发的条件达到了，可是如何把 <code>Signal(num() * 3)</code> 这样的对象传递给 num 的 set ？</p><p>这个时候就需要在 Object Signal 里面新增一块用于维护方法调用的数据结构，没做就是 stack</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Signal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> caller = <span class="keyword">new</span> <span class="type">StackableVariable</span>[<span class="type">Signal</span>[_]](<span class="type">NoSignal</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](expr: =&gt; <span class="type">T</span>) = <span class="keyword">new</span> <span class="type">Signal</span>(expr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StackableVariable 在当前的上下文中多个 Signal/Object 会共享。当调用 class Signal 的 apply() 方法的时候就去这里面找到当前的调用方。</p><h3 id="维护调用栈"><a href="#维护调用栈" class="headerlink" title="维护调用栈"></a>维护调用栈</h3><p>调用栈里面存放有序的 Signal。例如，有下面测试代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">"multi subscribers"</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> publisher = <span class="type">Var</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">val</span> subscriber1 = <span class="type">Signal</span>(publisher() * <span class="number">20</span>) <span class="comment">// 注意 scala 的 call-by-name 和 call-by-value。这里传递的是表达式</span></span><br><span class="line">  <span class="keyword">val</span> subscriber2 = <span class="type">Signal</span>(publisher() * <span class="number">30</span>)</span><br><span class="line">  <span class="keyword">val</span> subscriber3 = <span class="type">Signal</span>(publisher() * <span class="number">40</span>)</span><br><span class="line">  assert(subscriber1() == <span class="number">20</span>)</span><br><span class="line">  assert(subscriber2() == <span class="number">30</span>)</span><br><span class="line">  assert(subscriber3() == <span class="number">40</span>)</span><br><span class="line">  publisher() = <span class="number">2</span></span><br><span class="line">  assert(subscriber1() == <span class="number">40</span>)</span><br><span class="line">  assert(subscriber2() == <span class="number">60</span>)</span><br><span class="line">  assert(subscriber3() == <span class="number">80</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三行开始，包含表达式的 Signal 进入调用栈，并不断被带入 subscriber 的集合。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackableVariable</span>[<span class="type">T</span>](<span class="params">init: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> values: <span class="type">List</span>[<span class="type">T</span>] = <span class="type">List</span>(init)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">T</span> = values.head</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withValue</span></span>[<span class="type">R</span>](newValue: <span class="type">T</span>)(op: =&gt; <span class="type">R</span>): <span class="type">R</span> = &#123;</span><br><span class="line">    values = newValue :: values</span><br><span class="line">    <span class="keyword">try</span> op <span class="keyword">finally</span> values = values.tail</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/razertory/scala-code-lab/blob/master/src/main/scala/scalaschool/SubPub.scala" target="_blank" rel="noopener">完整代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这个 2020 年初的特殊时期。&lt;/p&gt;
&lt;p&gt;Scala 是一门现代化，多范式的 JVM 语言。&lt;/p&gt;
&lt;p&gt;传送门（可能需要🚀)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.coursera.org/learn/progfun2&quot; targ
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LRU 缓存</title>
    <link href="https://razertory.me/2020/02/16/lru-cache/"/>
    <id>https://razertory.me/2020/02/16/lru-cache/</id>
    <published>2020-02-16T09:39:04.000Z</published>
    <updated>2020-03-28T13:02:10.018Z</updated>
    
    <content type="html"><![CDATA[<p>LRU 的全称是 Least recently used，是缓存替换策略的一种。电脑存储器空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。此原则即所谓缓存替换策略。<br><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">传送门</a></p><hr><p>实现 LRU 缓存需要用到 kv 类型和线型的数据结构，用来做到 O(1) 的查找效率和实现淘汰机制。我们可以用 HashMap 和一个双向链表。其中用双向链表的好处是：当要删除的节点为 node 的时候，通过 <code>node.pre</code> 和 <code>node.next</code> 可以快速找到前后节点，从而在链表中去掉这个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    LinkNode prev;</span><br><span class="line">    LinkNode next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新增的 node 只作为 head</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(LinkNode node)</span> </span>&#123;</span><br><span class="line">    node.prev = head;</span><br><span class="line">    node.next = head.next;</span><br><span class="line"></span><br><span class="line">    head.next.prev = node;</span><br><span class="line">    head.next = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 prev 和 next 快速删除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(LinkNode node)</span></span>&#123;</span><br><span class="line">    LinkNode prev = node.prev;</span><br><span class="line">    LinkNode next = node.next;</span><br><span class="line"></span><br><span class="line">    prev.next = next;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先删除，后新增从而指向头部</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(LinkNode node)</span></span>&#123;</span><br><span class="line">    removeNode(node);</span><br><span class="line">    addNode(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 淘汰末尾</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> LinkNode <span class="title">popTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkNode res = tail.prev;</span><br><span class="line">    removeNode(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;Integer, LinkNode&gt; cache =</span><br><span class="line">          <span class="keyword">new</span> HashMap&lt;Integer, LinkNode&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">  <span class="keyword">private</span> LinkNode head, tail;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">    head = <span class="keyword">new</span> LinkNode();</span><br><span class="line">    tail = <span class="keyword">new</span> LinkNode();</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    LinkNode node = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    moveToHead(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    LinkNode node = cache.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">      LinkNode newNode = <span class="keyword">new</span> LinkNode();</span><br><span class="line">      newNode.key = key;</span><br><span class="line">      newNode.value = value;</span><br><span class="line"></span><br><span class="line">      cache.put(key, newNode);</span><br><span class="line">      addNode(newNode);</span><br><span class="line"></span><br><span class="line">      ++size;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(size &gt; capacity) &#123;</span><br><span class="line">        LinkNode tail = popTail();</span><br><span class="line">        cache.remove(tail.key);</span><br><span class="line">        --size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = value;</span><br><span class="line">      moveToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种更为优雅的实现是让这个双向链表成环状，初始化为 value 都为 -1，大小为 capacity。每当有 get 和 put 操作的时候就调整环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key, val;</span><br><span class="line">        Node next, pre;</span><br><span class="line">        Node(<span class="keyword">int</span> key, <span class="keyword">int</span> val, Node pre, Node next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.pre = pre;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move2Head</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == head) &#123;</span><br><span class="line">            head = head.pre;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.pre.next = cur.next;</span><br><span class="line">        cur.next.pre = cur.pre;</span><br><span class="line"></span><br><span class="line">        cur.next = head.next;</span><br><span class="line">        cur.next.pre = cur;</span><br><span class="line">        head.next = cur;</span><br><span class="line">        cur.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>, cur, <span class="keyword">null</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = head;</span><br><span class="line">        head.pre = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        move2Head(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            node.val = val;</span><br><span class="line">            move2Head(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val != -<span class="number">1</span>) map.remove(head.key);</span><br><span class="line">            head.key = key;</span><br><span class="line">            head.val = val;</span><br><span class="line">            map.put(key, head);</span><br><span class="line">            head = head.pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Java 中的 LinkedHashMap 可以直接实现 LRU 缓存。:)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LRU 的全称是 Least recently used，是缓存替换策略的一种。电脑存储器空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。此原则即所谓缓存替换策略。&lt;br&gt;&lt;a href=&quot;https://
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编辑距离</title>
    <link href="https://razertory.me/2020/01/11/edit-distance/"/>
    <id>https://razertory.me/2020/01/11/edit-distance/</id>
    <published>2020-01-11T03:35:32.000Z</published>
    <updated>2020-03-28T13:02:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>给出两个单词 word1 和 word2，找出把 word1 编辑成 word2 的最短编辑距离。给出的可用编辑操作有：</p><ol><li>插入一个字符 insert</li><li>删除一个字符 delete</li><li>更新一个字符 update</li></ol><blockquote><p>编辑距离是针对二个字符串（例如英文字）的差异程度的量化量测，量测方式是看至少需要多少次的处理才能将一个字符串变成另一个字符串。编辑距离可以用在自然语言处理中，例如拼写检查可以根据一个拼错的字和其他正确的字的编辑距离，判断哪一个（或哪几个）是比较可能的字。DNA也可以视为用A、C、G和T组成的字符串，因此编辑距离也用在生物信息学中，判断二个DNA的类似程度。Unix 下的 diff 及 patch 即是利用编辑距离来进行文本编辑对比的例子。</p></blockquote><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">传送门</a></h2><p>对于 “a”, “”, 执行步骤 1<br>对于 “”, “a”, 执行步骤 2<br>对于 “a”, “b”, 执行步骤 3</p><p>假设字符串串 word1 和 word2 的最小编辑距离是 <code>d[i][j]</code> (i 和 j 代表 word1 和 word2 的长度 - 1)，当我们给 word1 和 word2 都 append 一个相同的字符的时候，这个编辑距离不变。因此可以认为，此时的 <code>d[i+1][j+1] == d[i][j]</code>。当 append 的字符不同的的时候。就是找到之前的最小编辑距离 + 1，这个之前的最小编辑距离可能是 <code>d[i][j]</code>、<code>d[i][j+1]</code>、或者 <code>d[i+1][j]</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/a67b702fgy1gasiec3bhgj204q0710sl.jpg" alt="Edit-Distance.png" title>                </div>                <div class="image-caption">Edit-Distance.png</div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = word1.length() + <span class="number">1</span>, n = word2.length() + <span class="number">1</span>; <span class="comment">//多的一行留给空字符串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            d[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            d[<span class="number">0</span>][j] = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    d[i][j] = d[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d[i][j] = min(d[i-<span class="number">1</span>][j-<span class="number">1</span>], d[i][j-<span class="number">1</span>], d[i-<span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给出两个单词 word1 和 word2，找出把 word1 编辑成 word2 的最短编辑距离。给出的可用编辑操作有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入一个字符 insert&lt;/li&gt;
&lt;li&gt;删除一个字符 delete&lt;/li&gt;
&lt;li&gt;更新一个字符 update&lt;/li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二维数组中和最小路径</title>
    <link href="https://razertory.me/2020/01/11/minimum-path-sum/"/>
    <id>https://razertory.me/2020/01/11/minimum-path-sum/</id>
    <published>2020-01-11T02:38:44.000Z</published>
    <updated>2020-03-28T13:02:10.017Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 m * n 大的非负组整数组成的二维数组中，找到一条从 left-top 到 right-bottom 的和最小的路径。输出这个路径的值。<a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">传送门</a></p><hr><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在这样一个矩阵中，从 <code>m[0][0]</code> 到 <code>m[2][2]</code> 的最短路径，可以看作是 <code>m[0][0]</code> 到 <code>m[1][2]</code> 的最短路径 (1-&gt;3-&gt;1-&gt;1) 以及 <code>m[2][1]</code> 的最短路径中取到的最小值 (1-&gt;1-&gt;4-&gt;2) 加上 <code>m[2][2]</code> 取到的最小值 1-&gt;3-&gt;1-&gt;1-&gt;1。因此可以得到关系式 </p><p><code>dp[m][n] = min(dp[m-1][n], dp[m][n-1]) + g[m][n]</code></p><p>利用这个关系式，处理好 m，n 为 0 的边界情况即可得出最短路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[m][n] = min(dp[m-1][n], dp[m][n-1]) + g[m][n] </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] g)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span> || g[<span class="number">0</span>] == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = g.length, w = g[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[h][w];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = g[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>] + g[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + g[i][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + g[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[h-<span class="number">1</span>][w-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在一个 m * n 大的非负组整数组成的二维数组中，找到一条从 left-top 到 right-bottom 的和最小的路径。输出这个路径的值。&lt;a href=&quot;https://leetcode.com/problems/minimum-path-sum/&quot; target
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="https://razertory.me/2020/01/11/longest-palindromic-substring/"/>
    <id>https://razertory.me/2020/01/11/longest-palindromic-substring/</id>
    <published>2020-01-11T02:00:36.000Z</published>
    <updated>2020-03-28T13:02:10.017Z</updated>
    
    <content type="html"><![CDATA[<p>给一个字符串 s，找到其中最长的回文串。<a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">传送门</a></p><hr><p>回文串有两种模式，一种是 aabb 类型，另一种是 aacbb 类型。当我们对一个字符串做是否是回文的时候可以实现一个 expand 函数用作判断<code>int expand(String s, int lelf, int right)</code> 当 s[left] == s[right] 且 left 和 right 没有到达字符串边界的时候计算长度即 <code>right - left + 1</code>。</p><p>实现了 expand 之后，对于任意字符串可以确认：</p><ol><li>字符串长度为 1 的时候，本身就是回文串</li><li>字符串长度为 2 的时候，判断两个字符是否相等，相等说明本身是，否则和 1 一致</li><li>字符串长度为 n 的时候，在对字符串进行从左到右扫描找到最大值 <code>max (expand(s, i, i), expand(s, i, i + 1))</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expand(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expand(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">                start = i - (len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + max);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给一个字符串 s，找到其中最长的回文串。&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>抢劫房子</title>
    <link href="https://razertory.me/2020/01/11/house-robber/"/>
    <id>https://razertory.me/2020/01/11/house-robber/</id>
    <published>2020-01-11T01:33:19.000Z</published>
    <updated>2020-03-28T13:02:10.017Z</updated>
    
    <content type="html"><![CDATA[<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">传送门</a></p><hr><p>假设房子定义为 <code>house[i]</code></p><p>房屋数量是 1 的时候，小偷只能偷这一家 <code>house[0]</code>。</p><p>房屋数量是 2 的时候，小偷从现有的选一个多的，也就是 <code>max(house[0], house[1])</code></p><p>房屋数量是 3 的时候，小偷的选择为 <code>max(house[0] + house[2], house[1])</code></p><p>如果我们知道房屋数量为 i - 1 的时候，小偷的最佳选择是 <code>d[i-1]</code>，那么当再增加一个房屋，即房屋数量为 i 的时候。依据题意可以推导出</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[i] = max(house[i] + d[i-<span class="number">2</span>], d[i-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>翻译成代码就是 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) d[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) d[i] = Math.max(nums[i], nums[i-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> d[i] = Math.max(d[i-<span class="number">2</span>] + nums[i], d[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。&lt;br&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>买卖股票的最大利润</title>
    <link href="https://razertory.me/2020/01/09/max-stock-profit/"/>
    <id>https://razertory.me/2020/01/09/max-stock-profit/</id>
    <published>2020-01-09T05:02:03.000Z</published>
    <updated>2020-03-28T13:02:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖 一次 该股票可能获得的利润是多少？</p><p>例如一只股票在某些时间节点的价格为 [9, 11, 8, 5, 7, 12, 16, 14]。</p><p>如果我们能在价格为 5 的时候买入并在价格为 16 时卖出，则能收获最大的利润 11。<br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">传送门</a></p><hr><p>股票最大利润，其实就是个从头到尾一直更新最大利润。最大利润 = Math.max(前面的最大利润，当前股票价格 - 前面最低价格)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>], maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        min = Math.min(min, nums[i]);</span><br><span class="line">        maxProfit = Math.max(maxProfit, nums[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖 一次 该股票可能获得的利润是多少？&lt;/p&gt;
&lt;p&gt;例如一只股票在某些时间节点的价格为 [9, 11, 8, 5, 7, 12, 16, 14]。&lt;/p&gt;
&lt;p&gt;如果我们能在价格为 5 的时候买入并在价格为 16 时卖
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2020 新年快乐</title>
    <link href="https://razertory.me/2020/01/01/happy-new-year-2020/"/>
    <id>https://razertory.me/2020/01/01/happy-new-year-2020/</id>
    <published>2020-01-01T04:25:41.000Z</published>
    <updated>2020-03-28T13:02:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>现在是 2020 年的一月一日，和普通放假的日常一样：1. KFC，2.电脑， 3.看书/编程。和之前不一样的是，咖啡点的是加冰的美式。回想起过去的一年，不在办公室的时候，我通常也会去找一个地方学习，常做的事情有</p><ul><li>刷课。MIT 6.824、SICP 那种</li><li>刷 OJ。通常是 Leetcode 或者 codewars，其中在 leetcode 上打了一段时间的周赛</li><li>看书。通常都是计算机相关的书籍，最近看的是 FP 相关</li><li>写博客。和现在一样</li></ul><p>这些事情都是我换个人喜欢做的，但是对外却有优先级。比如说如果我最近要参加面试，我可能会花更多的时间在刷 OJ；如果我最近要用一门新语言/框架，我可能会选择看书；如果我最近时间比较充裕且没有外部的需求，那么我会像现在一样写博客或者用一段连续且足够长的时间来刷课程。</p><p>这么做既满足了自己的喜好，也能够根据外部的状态及调整。</p><p>随着时间的推移，我越来越觉得自己即将成为那种很标准的「职场码农」。快速完成外部的需求，给团队带来价值，快速学习一门新技术，快速补偿技术债。但是我自己也不得不承认，因为这种策略，我到目前没有那种能做到 top 的事情。首先解释一下做到 top：比如说刷 OJ，我可以通过周赛或者自己的积分排名来判断，或者我可以去给某个知名开源的框架做贡献，通过 contributors 排名来看自己做的程度。做到 top 有时候不仅仅是因为自己多多少少有「追名逐利」的情结，更因为我坚持认为，如果喜欢做一件事情，肯定有把事情做好的意愿，那么只要不断坚持做自然就会做到 top。</p><p>前段时间的一个周末，我去了一家摊饼店，拍下了一行字</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/mw690/a67b702fgy1gagzjtfpp5j20u01407fd.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如果说，一个人可以一辈子专注于一件事情上，并且不会被别的事情所干扰或者诱惑应该是非常值得羡慕的。可是如果用资本家的眼光去看待这个，肯定会让人觉得这个人只知道打工(这里不把打工做贬义)。我记得在「泰囧」电影里面有个对白</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/mw690/a67b702fgy1gah030l1rhj20rs0doq4n.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/mw690/a67b702fgy1gah03e89o2j20rt0dt40p.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>资本家热爱「挣钱」本身这件事情，所以会用经营、扩张的眼光去看待做葱油饼。葱油饼小哥说秘方就是要自己亲自做，新鲜出炉，这是热爱做葱油饼人的眼光。不过这个世界就是需要这两种人。</p><p>如果把「做葱油饼」换成「写代码」，这个对白产生的效果应该是类似的。</p><p>我想说不论是为了更高的薪水不断学习，还是因为热爱编程本身不断学习，这两者应该是都被认可的。在现实世界中，我认为这两种动机应该是都存在的，或者说人本身就是这样的，既希望做的事情是自己喜欢的，也希望做的事情能给自己带来更多收入。</p><p>2020年，我们是野性和文明共存的。</p><p>新年快乐！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是 2020 年的一月一日，和普通放假的日常一样：1. KFC，2.电脑， 3.看书/编程。和之前不一样的是，咖啡点的是加冰的美式。回想起过去的一年，不在办公室的时候，我通常也会去找一个地方学习，常做的事情有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷课。MIT 6.824、SICP
      
    
    </summary>
    
    
      <category term="思考" scheme="https://razertory.me/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>有序数组转化为平衡二叉搜索树（BST）</title>
    <link href="https://razertory.me/2019/12/12/sorted-arr-to-bst/"/>
    <id>https://razertory.me/2019/12/12/sorted-arr-to-bst/</id>
    <published>2019-12-12T13:41:57.000Z</published>
    <updated>2020-03-28T13:02:10.016Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个有序数组，数组元素升序排列，试将该数组转换为一棵平衡二叉搜索树（Balanced Binary Search Tree）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">convertToBST</span><span class="params">(ArrayList&lt;Integer&gt; arr)</span></span></span><br></pre></td></tr></table></figure><p>根据 BST 的定义 <em>二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索,插入,删除的复杂度等于树高，O(log(n)).</em> 可以对其进行反中序的遍历。也就是 中-左-右 的一个逆向过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">convertToBST</span><span class="params">(ArrayList&lt;Integer&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> convert(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode <span class="title">convert</span><span class="params">(ArrayList&lt;Integer&gt; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(arr[mid]);</span><br><span class="line">    node.left = convert(arr, start, mid - <span class="number">1</span>);</span><br><span class="line">    node.right = convert(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个有序数组，数组元素升序排列，试将该数组转换为一棵平衡二叉搜索树（Balanced Binary Search Tree）。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>完美的二分搜索</title>
    <link href="https://razertory.me/2019/11/28/binary-search/"/>
    <id>https://razertory.me/2019/11/28/binary-search/</id>
    <published>2019-11-28T14:45:06.000Z</published>
    <updated>2020-03-28T13:02:10.014Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>假设给一个有序的 int 类型的数组 arr，和一个目标值 target，找到这个目标值在数组中的下标。如果数组中没有<br>target 返回 -1。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>; <span class="comment">// 需要注意用 (start + end) / 2 在数学上没有问题。但是考虑到 start + end 可能会溢出。</span></span><br><span class="line">        <span class="keyword">if</span> (target == arr[mid]) </span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid])</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start + mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;假设给一个有序的 int 类型的数组 arr，和一个目标值 target，找到这个目标值在数组中的下标。如果数组中没有&lt;br&gt;target 返回 -1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汉明距离</title>
    <link href="https://razertory.me/2019/11/17/hamming-distance/"/>
    <id>https://razertory.me/2019/11/17/hamming-distance/</id>
    <published>2019-11-17T02:46:03.000Z</published>
    <updated>2020-03-28T13:02:10.013Z</updated>
    
    <content type="html"><![CDATA[<p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br></pre></td></tr></table></figure><p>对于 x, 和 y 先进行异或，然后再计算结果中的 1 的个数即可。（其中 count 算法来自 <a href="/2019/11/14/count-of-one/">二进制中 1 的个数</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = x ^ y;</span><br><span class="line">    <span class="keyword">return</span> count(n); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>只出现一次的数</title>
    <link href="https://razertory.me/2019/11/17/single-number/"/>
    <id>https://razertory.me/2019/11/17/single-number/</id>
    <published>2019-11-17T02:31:09.000Z</published>
    <updated>2020-03-28T13:02:10.013Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span></span><br></pre></td></tr></table></figure><p>计算机科学中，异或满足四大定律</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.恒定律：A ^ 0 = A</span><br><span class="line">2.归零率：A ^ A = 0</span><br><span class="line">3.交换律：A ^ B = B ^ A</span><br><span class="line">4.结合律：(A ^ B) ^ C = A ^ (B ^ C)</span><br></pre></td></tr></table></figure><p>假如给定的数组是 [1, 3, 1, 3, 2, 4, 4]。根据异或的定律，对数组从头到尾进行异或可以等价成分组之后的异或，这里可以理解成 [1, 1, 2, 3, 3, 4, 4]。相同的数都会变为 0 ，最后剩下的那个数也就和 0 进行异或等到自己本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        result ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个数多于一半的数</title>
    <link href="https://razertory.me/2019/11/16/major-element/"/>
    <id>https://razertory.me/2019/11/16/major-element/</id>
    <published>2019-11-16T12:08:11.000Z</published>
    <updated>2020-03-28T13:02:10.013Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个大小为 n 的数组，找出其中在数组中出现次数大于 ⌊ n/2 ⌋ 的元素（众数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span></span><br></pre></td></tr></table></figure><p>理解这个问题，首先可以把数组分为两个部分：所有的众数和非众数。把众数和非众数进行两两抵消，那么最后一定还剩下众数。实际上这个也就是摩尔投票法。在遍历数组的时候不断确认当前的众数，如果没有，则认为下一个就是。维护一个计数器，在遇到相同的时候给众数 +1，不同的时候 -1。当计数器为 0 的时候认为没有众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Integer candidate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            candidate = num;</span><br><span class="line">        &#125;</span><br><span class="line">        count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个大小为 n 的数组，找出其中在数组中出现次数大于 ⌊ n/2 ⌋ 的元素（众数）。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二进制中 1 的个数</title>
    <link href="https://razertory.me/2019/11/14/count-of-one/"/>
    <id>https://razertory.me/2019/11/14/count-of-one/</id>
    <published>2019-11-14T01:42:44.000Z</published>
    <updated>2020-03-28T13:02:10.013Z</updated>
    
    <content type="html"><![CDATA[<p>对于任意整数，求转换成二进制数之后，1 的个数。比如 5 转换成二进制是 101，其中 1 的个数是 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span> <span class="params">(<span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure><p>要判断一个二进制数的最低位是否是 1，只需要和 1 进行 <code>&amp;</code> 运算即可。那么具体的做法就一边移位一边统计。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &amp; <span class="number">1</span> == <span class="number">1</span>) count++;</span><br><span class="line">        num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于任意整数，求转换成二进制数之后，1 的个数。比如 5 转换成二进制是 101，其中 1 的个数是 2。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>位运算实现加法</title>
    <link href="https://razertory.me/2019/11/11/add-by-bit/"/>
    <id>https://razertory.me/2019/11/11/add-by-bit/</id>
    <published>2019-11-11T14:56:31.000Z</published>
    <updated>2020-03-28T13:02:10.013Z</updated>
    
    <content type="html"><![CDATA[<p>计算机科学中，基础运算运算都来自于二进制中的位运算。其中不免提到加法器，维基百科是这么定义的</p><blockquote><p>在电子学中，加法器（英语：adder）是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统中，加法器主要负责计算地址、索引等数据。除此之外，加法器也是其他一些硬件，例如二进制数的乘法器的重要组成部分。<br>尽管可以为不同计数系统设计专门的加法器，但是由于数字电路通常以二进制为基础，因此二进制加法器在实际应用中最为普遍。在数字电路中，二进制数的减法可以通过加一个负数来间接完成。为了使负数的计算能够直接用加法器来完成，计算中的负数可以使用二补数（补码）来表示，具体的细节可以参考数字电路相关的书籍</p></blockquote><p>对两个二进制数做相加，有以下规律</p><p><em>二进制加法</em></p><table><thead><tr><th>x</th><th>y</th><th>和</th><th>进位</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>假设 x + y 相加用代码表示，那么就需要一个 sum 和 carry 分别表示和与进位。不过这个还不足够表示两个数相加。</p><p>仔细观察可以发现 x + y 的 sum 和 carry 其实分别是异或<code>^</code>和与<code>&amp;</code>运算。如下：</p><p><em>异或</em></p><table><thead><tr><th>x</th><th>y</th><th>^</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p><em>与</em></p><table><thead><tr><th>x</th><th>y</th><th>&amp;</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制实现加法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> sum = a;</span><br><span class="line">　　<span class="keyword">int</span> carry = b;</span><br><span class="line">　　<span class="keyword">while</span>(carry != <span class="number">0</span> ) &#123;</span><br><span class="line">　　　　<span class="keyword">int</span> tmps = sum;</span><br><span class="line"> </span><br><span class="line">　　　　sum = tmps ^ carry;</span><br><span class="line">　　　　carry = (tmps &amp; carry) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机科学中，基础运算运算都来自于二进制中的位运算。其中不免提到加法器，维基百科是这么定义的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在电子学中，加法器（英语：adder）是一种用于执行加法运算的数字电路部件，是构成电子计算机核心微处理器中算术逻辑单元的基础。在这些电子系统
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>括号的合法序列</title>
    <link href="https://razertory.me/2019/11/10/valid-brackets/"/>
    <id>https://razertory.me/2019/11/10/valid-brackets/</id>
    <published>2019-11-10T01:55:10.000Z</published>
    <updated>2020-03-28T13:02:10.012Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个括号序列，里面包含小括号，中括号和大括号。你要判断这个括号序列是否有效。有效的括号序列要求，每个左括号都必须有一个同类的右括号与它正确配对。另外，空字符串认为是有效的括号序列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">比如说，给你的序列是：</span><br><span class="line"></span><br><span class="line">()[]&#123;&#125;</span><br><span class="line"></span><br><span class="line">小括号/中括号/大括号的左右括号都能正确配对，因此这是一个有效的括号序列。</span><br><span class="line"></span><br><span class="line">再比如说给你的序列是：</span><br><span class="line"></span><br><span class="line">([)]</span><br><span class="line"></span><br><span class="line">这里面虽然正好有一对小括号和一对中括号，但它们的顺序不对，括号间无法正确配对，因此这不是一个有效的括号序列</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBrackets</span><span class="params">(String s)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>维护一个 stack，存放 char。在遍历 s 的过程中，不断对遇到左括号进行 push，右括号进行 pop。当最后 stack 为空的时候说明是合法的括号序列.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBrackets</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span> || s.charAt(i) == <span class="string">'['</span> || s.charAt(i) == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">        stack.push(s.charAt(i));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span> &amp;&amp; stack.peek() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">']'</span> &amp;&amp; stack.peek() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'&#125;'</span> &amp;&amp; stack.peek() != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.pop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给你一个括号序列，里面包含小括号，中括号和大括号。你要判断这个括号序列是否有效。有效的括号序列要求，每个左括号都必须有一个同类的右括号与它正确配对。另外，空字符串认为是有效的括号序列。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>栈实现队列</title>
    <link href="https://razertory.me/2019/11/10/queue-by-stack/"/>
    <id>https://razertory.me/2019/11/10/queue-by-stack/</id>
    <published>2019-11-10T01:45:31.000Z</published>
    <updated>2020-03-28T13:02:10.012Z</updated>
    
    <content type="html"><![CDATA[<p>维护一个 in，out 栈表示进出顺序，实现一个从 in 到 out 的转移方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in, out;</span><br><span class="line"></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        in.push(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        transferIfEmpty();</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        transferIfEmpty();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferIfEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.empty()) &#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;维护一个 in，out 栈表示进出顺序，实现一个从 in 到 out 的转移方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>uber-go-guide</title>
    <link href="https://razertory.me/2019/11/08/uber-go-guide-cn/"/>
    <id>https://razertory.me/2019/11/08/uber-go-guide-cn/</id>
    <published>2019-11-08T00:04:22.000Z</published>
    <updated>2020-03-28T13:02:10.012Z</updated>
    
    <content type="html"><![CDATA[<p>本文长期维护地址: <a href="https://github.com/xxjwxc/uber_go_guide_cn" target="_blank" rel="noopener">https://github.com/xxjwxc/uber_go_guide_cn</a></p><h1 id="Uber-Go-语言编码规范"><a href="#Uber-Go-语言编码规范" class="headerlink" title="Uber Go 语言编码规范"></a>Uber Go 语言编码规范</h1><p> <a href="https://www.uber.com/" target="_blank" rel="noopener">Uber</a> 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 <a href="https://github.com/uber-go/zap" target="_blank" rel="noopener">zap</a>、<a href="https://github.com/jaegertracing/jaeger" target="_blank" rel="noopener">jaeger</a> 等。2018 年年末 Uber 将内部的 <a href="https://github.com/uber-go/guide" target="_blank" rel="noopener">Go 风格规范</a> 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 Gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>当前更新版本：2019-11-01 版本地址：<a href="https://github.com/uber-go/guide/commit/7eb64c6cb304471c868273d919c2d34993e2daa7" target="_blank" rel="noopener">commit:#68</a></li><li>如果您发现任何更新、问题或改进，请随时 fork 和 PR</li><li>Please feel free to fork and PR if you find any updates, issues or improvement.</li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#介绍">介绍</a></li><li><a href="#指导原则">指导原则</a><ul><li><a href="#指向-interface-的指针">指向 interface 的指针</a></li><li><a href="#接收器-receiver-与接口">接收器 (receiver) 与接口</a></li><li><a href="#零值-Mutex-是有效的">零值 Mutex 是有效的</a></li><li><a href="#在边界处拷贝-Slices-和-Maps">在边界处拷贝 Slices 和 Maps</a></li><li><a href="#使用-defer-释放资源">使用 defer 释放资源</a></li><li><a href="#Channel-的-size-要么是-1要么是无缓冲的">Channel 的 size 要么是 1，要么是无缓冲的</a></li><li><a href="#枚举从-1-开始">枚举从 1 开始</a></li><li><a href="#错误类型">错误类型</a></li><li><a href="#错误包装-(Error-Wrapping)">错误包装 (Error Wrapping)</a></li><li><a href="#处理类型断言失败">处理类型断言失败</a></li><li><a href="#不要-panic">不要 panic</a></li><li><a href="#使用-gouberorgatomic">使用 go.uber.org/atomic</a></li></ul></li><li><a href="#性能">性能</a><ul><li><a href="#优先使用-strconv-而不是-fmt">优先使用 strconv 而不是 fmt</a></li><li><a href="#避免字符串到字节的转换">避免字符串到字节的转换</a></li><li><a href="#尽量初始化时指定-Map-容量">尽量初始化时指定 Map 容量</a></li></ul></li><li><a href="#规范">规范</a><ul><li><a href="#一致性">一致性</a></li><li><a href="#相似的声明放在一组">相似的声明放在一组</a></li><li><a href="#import-分组">import 分组</a></li><li><a href="#包名">包名</a></li><li><a href="#函数名">函数名</a></li><li><a href="#导入别名">导入别名</a></li><li><a href="#函数分组与顺序">函数分组与顺序</a></li><li><a href="#减少嵌套">减少嵌套</a></li><li><a href="#不必要的-else">不必要的 else</a></li><li><a href="#顶层变量声明">顶层变量声明</a></li><li><a href="#对于未导出的顶层常量和变量使用_作为前缀">对于未导出的顶层常量和变量，使用_作为前缀</a></li><li><a href="#结构体中的嵌入">结构体中的嵌入</a></li><li><a href="#使用字段名初始化结构体">使用字段名初始化结构体</a></li><li><a href="#本地变量声明">本地变量声明</a></li><li><a href="#nil-是一个有效的-slice">nil 是一个有效的 slice</a></li><li><a href="#小变量作用域">小变量作用域</a></li><li><a href="#避免参数语义不明确Avoid-Naked-Parameters">避免参数语义不明确（Avoid Naked Parameters）</a></li><li><a href="#使用原始字符串字面值避免转义">使用原始字符串字面值，避免转义</a></li><li><a href="#初始化-Struct-引用">初始化 Struct 引用</a></li><li><a href="#初始化-maps">初始化 Maps</a></li><li><a href="#字符串-string-format">字符串 string format </a></li><li><a href="#命名-Printf-样式的函数">命名 Printf 样式的函数</a></li></ul></li><li><a href="#编程模式">编程模式</a><ul><li><a href="#表驱动测试">表驱动测试</a></li><li><a href="#功能选项">功能选项</a></li></ul></li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>样式 (style) 是支配我们代码的惯例。术语<code>样式</code>有点用词不当，因为这些约定涵盖的范围不限于由 gofmt 替我们处理的源文件格式。</p><p>本指南的目的是通过详细描述在 Uber 编写 Go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能。</p><p>该指南最初由 <a href="https://github.com/prashantv" target="_blank" rel="noopener">Prashant Varanasi</a> 和 <a href="https://github.com/nomis52" target="_blank" rel="noopener">Simon Newton</a> 编写，目的是使一些同事能快速使用 Go。多年来，该指南已根据其他人的反馈进行了修改。</p><p>本文档记录了我们在 Uber 遵循的 Go 代码中的惯用约定。其中许多是 Go 的通用准则，而其他扩展准则依赖于下面外部的指南：</p><ol><li><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a></li><li><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">The Go common mistakes guide</a></li></ol><p>所有代码都应该通过<code>golint</code>和<code>go vet</code>的检查并无错误。我们建议您将编辑器设置为：</p><ul><li>保存时运行 <code>goimports</code></li><li>运行 <code>golint</code> 和 <code>go vet</code> 检查错误</li></ul><p>您可以在以下 Go 编辑器工具支持页面中找到更为详细的信息：<br><a href="https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins" target="_blank" rel="noopener">https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins</a></p><h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><h3 id="指向-interface-的指针"><a href="#指向-interface-的指针" class="headerlink" title="指向 interface 的指针"></a>指向 interface 的指针</h3><p>您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。</p><p>接口实质上在底层用两个字段表示：</p><ol><li>一个指向某些特定类型信息的指针。您可以将其视为”type”。</li><li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li></ol><p>如果希望接口方法修改基础数据，则必须使用指针传递。</p><h3 id="接收器-receiver-与接口"><a href="#接收器-receiver-与接口" class="headerlink" title="接收器 (receiver) 与接口"></a>接收器 (receiver) 与接口</h3><p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。</p><p>例如，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">  data <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">Read</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span> <span class="title">Write</span><span class="params">(str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  s.data = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sVals := <span class="keyword">map</span>[<span class="keyword">int</span>]S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你只能通过值调用 Read</span></span><br><span class="line">sVals[<span class="number">1</span>].Read()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这不能编译通过：</span></span><br><span class="line"><span class="comment">//  sVals[1].Write("test")</span></span><br><span class="line"></span><br><span class="line">sPtrs := <span class="keyword">map</span>[<span class="keyword">int</span>]*S&#123;<span class="number">1</span>: &#123;<span class="string">"A"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针既可以调用 Read，也可以调用 Write 方法</span></span><br><span class="line">sPtrs[<span class="number">1</span>].Read()</span><br><span class="line">sPtrs[<span class="number">1</span>].Write(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure><p>同样，即使该方法具有值接收器，也可以通过指针来满足接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> F <span class="keyword">interface</span> &#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S1)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> S2 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S2)</span> <span class="title">f</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">s1Val := S1&#123;&#125;</span><br><span class="line">s1Ptr := &amp;S1&#123;&#125;</span><br><span class="line">s2Val := S2&#123;&#125;</span><br><span class="line">s2Ptr := &amp;S2&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i F</span><br><span class="line">i = s1Val</span><br><span class="line">i = s1Ptr</span><br><span class="line">i = s2Ptr</span><br><span class="line"></span><br><span class="line"><span class="comment">//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器</span></span><br><span class="line"><span class="comment">//   i = s2Val</span></span><br></pre></td></tr></table></figure><p><a href="https://golang.org/doc/effective_go.html" target="_blank" rel="noopener">Effective Go</a> 中有一段关于 <a href="https://golang.org/doc/effective_go.html#pointers_vs_values" target="_blank" rel="noopener">pointers vs. values</a> 的精彩讲解。</p><h3 id="零值-Mutex-是有效的"><a href="#零值-Mutex-是有效的" class="headerlink" title="零值 Mutex 是有效的"></a>零值 Mutex 是有效的</h3><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu := <span class="built_in">new</span>(sync.Mutex)</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu.Lock()</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果你使用结构体指针，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。<br>如果是私有结构体类型或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：</p><table><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> smap <span class="keyword">struct</span> &#123;</span><br><span class="line">  sync.Mutex <span class="comment">// only for unexported types（仅适用于非导出类型）</span></span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSMap</span><span class="params">()</span> *<span class="title">smap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;smap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *smap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex <span class="comment">// 对于导出类型，请使用私有锁</span></span><br><span class="line"></span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span> *<span class="title">SMap</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;SMap&#123;</span><br><span class="line">    data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span> <span class="title">Get</span><span class="params">(k <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  m.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> m.data[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td>为私有类型或需要实现互斥接口的类型嵌入。</td><td>对于导出的类型，请使用专用字段。</td></tr></tbody></table><h3 id="在边界处拷贝-Slices-和-Maps"><a href="#在边界处拷贝-Slices-和-Maps" class="headerlink" title="在边界处拷贝 Slices 和 Maps"></a>在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p><h4 id="接收-Slices-和-Maps"><a href="#接收-Slices-和-Maps" class="headerlink" title="接收 Slices 和 Maps"></a>接收 Slices 和 Maps</h4><p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p><table><thead><tr><th>Bad</th> <th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = trips</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你是要修改 d1.trips 吗？</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">SetTrips</span><span class="params">(trips []Trip)</span></span> &#123;</span><br><span class="line">  d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))</span><br><span class="line">  <span class="built_in">copy</span>(d.trips, trips)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trips := ...</span><br><span class="line">d1.SetTrips(trips)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips</span></span><br><span class="line">trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h4 id="返回-slices-或-maps"><a href="#返回-slices-或-maps" class="headerlink" title="返回 slices 或 maps"></a>返回 slices 或 maps</h4><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot 返回当前状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s.counters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 不再受互斥锁保护</span></span><br><span class="line"><span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响</span></span><br><span class="line"><span class="comment">// 影响 stats.counters</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu sync.Mutex</span><br><span class="line"></span><br><span class="line">  counters <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>]<span class="title">int</span></span> &#123;</span><br><span class="line">  s.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="built_in">len</span>(s.counters))</span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;</span><br><span class="line">    result[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// snapshot 现在是一个拷贝</span></span><br><span class="line">snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="使用-defer-释放资源"><a href="#使用-defer-释放资源" class="headerlink" title="使用 defer 释放资源"></a>使用 defer 释放资源</h3><p>使用 defer 释放资源，诸如文件和锁。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  p.Unlock()</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line">newCount := p.count</span><br><span class="line">p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newCount</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当有多个 return 分支时，很容易遗忘 unlock</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.Lock()</span><br><span class="line"><span class="keyword">defer</span> p.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.count &lt; <span class="number">10</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.count++</span><br><span class="line"><span class="keyword">return</span> p.count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更可读</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p><h3 id="Channel-的-size-要么是-1，要么是无缓冲的"><a href="#Channel-的-size-要么是-1，要么是无缓冲的" class="headerlink" title="Channel 的 size 要么是 1，要么是无缓冲的"></a>Channel 的 size 要么是 1，要么是无缓冲的</h3><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。考虑如何确定大小，是什么阻止了 channel 在负载下被填满并阻止写入，以及发生这种情况时发生了什么。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应该足以满足任何情况！</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小：1</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 无缓冲 channel，大小为 0</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="枚举从-1-开始"><a href="#枚举从-1-开始" class="headerlink" title="枚举从 1 开始"></a>枚举从 1 开始</h3><p>在 Go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LogOutput <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  LogToStdout LogOutput = <span class="literal">iota</span></span><br><span class="line">  LogToFile</span><br><span class="line">  LogToRemote</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogToStdout=0, LogToFile=1, LogToRemote=2</span></span><br></pre></td></tr></table></figure><!-- TODO: section on String methods for enums --><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>Go 中有多种声明错误（Error) 的选项：</p><ul><li><a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 对于简单静态字符串的错误</li><li><a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> 用于格式化的错误字符串</li><li>实现 <code>Error()</code> 方法的自定义类型</li><li>用 <a href="https://godoc.org/github.com/pkg/errors#Wrap" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Wrap</code></a> 的 Wrapped errors</li></ul><p>返回错误时，请考虑以下因素以确定最佳选择：</p><ul><li>这是一个不需要额外信息的简单错误吗？如果是这样，<a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a> 足够了。</li><li>客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 <code>Error()</code> 方法。</li><li>您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 <a href="#错误包装" title="Error-Wrapping">section on error wrapping</a> 部分的内容。</li><li>否则 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a> 就可以了。</li></ul><p>如果客户端需要检测错误，并且您已使用创建了一个简单的错误 <a href="https://golang.org/pkg/errors/#New" target="_blank" rel="noopener"><code>errors.New</code></a>，请使用一个错误变量。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">"could not open"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err.Error() == <span class="string">"could not open"</span> &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">"could not open"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err == foo.ErrCouldNotOpen &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">"file %q not found"</span>, file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">"not found"</span>) &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(errNotFound); ok &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errNotFound <span class="keyword">struct</span> &#123;</span><br><span class="line">  file <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e errNotFound)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"file %q not found"</span>, e.file)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsNotFoundError</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  _, ok := err.(errNotFound)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(file <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errNotFound&#123;file: file&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(<span class="string">"foo"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> foo.IsNotFoundError(err) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"unknown error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- TODO: Exposing the information to callers with accessor functions. --><h3 id="错误包装-Error-Wrapping"><a href="#错误包装-Error-Wrapping" class="headerlink" title="错误包装 (Error Wrapping)"></a>错误包装 (Error Wrapping)</h3><p>一个（函数/方法）调用失败时，有三种主要的错误传播方式：</p><ul><li><p>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</p></li><li><p>添加上下文，使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Wrap</code></a> 以便错误消息提供更多上下文 ,<a href="https://godoc.org/github.com/pkg/errors#Cause" target="_blank" rel="noopener"><code>&quot;pkg/errors&quot;.Cause</code></a> 可用于提取原始错误。<br>Use fmt.Errorf if the callers do not need to detect or handle that specific error case.</p></li><li><p>如果调用者不需要检测或处理的特定错误情况，使用 <a href="https://golang.org/pkg/fmt/#Errorf" target="_blank" rel="noopener"><code>fmt.Errorf</code></a>。</p></li></ul><p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p><p>在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语来保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"failed to create new store: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">"new store: %s"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to x: failed to y: failed to create new store: the error</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x: y: new store: the error</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用<code>err</code>标记，或在日志中以”Failed”为前缀）。</p><p>另请参见 <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Don’t just check errors, handle them gracefully</a>. 不要只是检查错误，要优雅地处理错误</p><h3 id="处理类型断言失败"><a href="#处理类型断言失败" class="headerlink" title="处理类型断言失败"></a>处理类型断言失败</h3><p><a href="https://golang.org/ref/spec#Type_assertions" target="_blank" rel="noopener">type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// 优雅地处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><!-- TODO: There are a few situations where the single assignment form isfine. --><h3 id="不要-panic"><a href="#不要-panic" class="headerlink" title="不要 panic"></a>不要 panic</h3><p>在生产环境中运行的代码必须避免出现 panic。panic 是 <a href="https://en.wikipedia.org/wiki/Cascading_failure" target="_blank" rel="noopener">cascading failures</a> 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(bar <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(bar) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"bar must not be empty"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"USAGE: foo &lt;bar&gt;"</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  foo(os.Args[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(bar <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(bar) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">"bar must not be empty"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"USAGE: foo &lt;bar&gt;"</span>)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := foo(os.Args[<span class="number">1</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>panic/recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _statusTemplate = template.Must(template.New(<span class="string">"name"</span>).Parse(<span class="string">"_statusHTML"</span>))</span><br></pre></td></tr></table></figure><p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestFoo(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">f, err := ioutil.TempFile(<span class="string">""</span>, <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  t.Fatal(<span class="string">"failed to set up test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><!-- TODO: Explain how to use _test packages. --><h3 id="使用-go-uber-org-atomic"><a href="#使用-go-uber-org-atomic" class="headerlink" title="使用 go.uber.org/atomic"></a>使用 go.uber.org/atomic</h3><p>使用 <a href="https://golang.org/pkg/sync/atomic/" target="_blank" rel="noopener">sync/atomic</a> 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p><p><a href="https://godoc.org/go.uber.org/atomic" target="_blank" rel="noopener">go.uber.org/atomic</a> 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running <span class="keyword">int32</span>  <span class="comment">// atomic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f* foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> atomic.SwapInt32(&amp;f.running, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running == <span class="number">1</span>  <span class="comment">// race!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo <span class="keyword">struct</span> &#123;</span><br><span class="line">  running atomic.Bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> f.running.Swap(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="comment">// already running…</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// start the Foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *foo)</span> <span class="title">isRunning</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.running.Load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>性能方面的特定准则只适用于高频场景。</p><h3 id="优先使用-strconv-而不是-fmt"><a href="#优先使用-strconv-而不是-fmt" class="headerlink" title="优先使用 strconv 而不是 fmt"></a>优先使用 strconv 而不是 fmt</h3><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := fmt.Sprint(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  s := strconv.Itoa(rand.Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkFmtSprint-4    143 ns/op    2 allocs/op</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkStrconv-4    64.2 ns/op    1 allocs/op</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="避免字符串到字节的转换"><a href="#避免字符串到字节的转换" class="headerlink" title="避免字符串到字节的转换"></a>避免字符串到字节的转换</h3><p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write([]<span class="keyword">byte</span>(<span class="string">"Hello world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data := []<span class="keyword">byte</span>(<span class="string">"Hello world"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">  w.Write(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkBad-4   50000000   22.2 ns/op</span><br></pre></td></tr></table></figure></td><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkGood-4  500000000   3.25 ns/op</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="尽量初始化时指定-Map-容量"><a href="#尽量初始化时指定-Map-容量" class="headerlink" title="尽量初始化时指定 Map 容量"></a>尽量初始化时指定 Map 容量</h3><p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, hint)</span><br></pre></td></tr></table></figure><p>为 <code>make()</code> 提供容量信息（hint）尝试在初始化时调整 map 大小，<br>这减少了在将元素添加到 map 时增长和分配的开销。<br>注意，map 不能保证分配 hint 个容量。因此，即使提供了容量，添加元素仍然可以进行分配。 </p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo)</span><br><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">files, _ := ioutil.ReadDir(<span class="string">"./files"</span>)</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]os.FileInfo, <span class="built_in">len</span>(files))</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;</span><br><span class="line">    m[f.Name()] = f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr><tr><td><p><code>m</code> 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</p></td><td><p><code>m</code> 是有大小提示创建的；在运行时可能会有更少的分配。</p></td></tr></tbody></table><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p><p>但是最重要的是，<strong>保持一致</strong>.</p><p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p><p>相反，一个单一的代码库会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、<br>代码审查痛苦、而且增加 bug 数量</p><p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p><h3 id="相似的声明放在一组"><a href="#相似的声明放在一组" class="headerlink" title="相似的声明放在一组"></a>相似的声明放在一组</h3><p>Go 语言支持将相似的声明放在一个组内。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"a"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"b"</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"a"</span></span><br><span class="line">  <span class="string">"b"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>这同样适用于常量、变量和类型声明：</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Area <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="keyword">float64</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">  Area <span class="keyword">float64</span></span><br><span class="line">  Volume <span class="keyword">float64</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">  ENV_VAR = <span class="string">"MY_ENV"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Operation <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  Add Operation = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  Subtract</span><br><span class="line">  Multiply</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ENV_VAR = <span class="string">"MY_ENV"</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>分组使用的位置没有限制，例如：你可以在函数内部使用它们：</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> red = color.New(<span class="number">0xff</span>0000)</span><br><span class="line">  <span class="keyword">var</span> green = color.New(<span class="number">0x00ff</span>00)</span><br><span class="line">  <span class="keyword">var</span> blue = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    red   = color.New(<span class="number">0xff</span>0000)</span><br><span class="line">    green = color.New(<span class="number">0x00ff</span>00)</span><br><span class="line">    blue  = color.New(<span class="number">0x0000ff</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="import-分组"><a href="#import-分组" class="headerlink" title="import 分组"></a>import 分组</h3><p>导入应该分为两组：</p><ul><li>标准库</li><li>其他库</li></ul><p>默认情况下，这是 goimports 应用的分组。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"go.uber.org/atomic"</span></span><br><span class="line">  <span class="string">"golang.org/x/sync/errgroup"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><p>当命名包时，请按下面规则选择一个名称：</p><ul><li>全部小写。没有大写或下划线。</li><li>大多数使用命名导入的情况下，不需要重命名。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li><li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</li></ul><p>另请参阅 <a href="https://blog.golang.org/package-names" target="_blank" rel="noopener">Package Names</a> 和 <a href="https://rakyll.org/style-packages/" target="_blank" rel="noopener">Go 包样式指南</a>.</p><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>我们遵循 Go 社区关于使用 <a href="https://golang.org/doc/effective_go.html#mixed-caps" target="_blank" rel="noopener">MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p><h3 id="导入别名"><a href="#导入别名" class="headerlink" title="导入别名"></a>导入别名</h3><p>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">  client <span class="string">"example.com/client-go"</span></span><br><span class="line">  trace <span class="string">"example.com/trace/v2"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"runtime/trace"</span></span><br><span class="line"></span><br><span class="line">  nettrace <span class="string">"golang.net/x/trace"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="函数分组与顺序"><a href="#函数分组与顺序" class="headerlink" title="函数分组与顺序"></a>函数分组与顺序</h3><ul><li>函数应按粗略的调用顺序排序。</li><li>同一文件中的函数应按接收者分组。</li></ul><p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p><p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>/<code>NewXYZ()</code> </p><p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> something <span class="keyword">struct</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSomething</span><span class="params">()</span> *<span class="title">something</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;something&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Cost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> calcCost(s.weights)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *something)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCost</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="减少嵌套"><a href="#减少嵌套" class="headerlink" title="减少嵌套"></a>减少嵌套</h3><p>代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;</span><br><span class="line">    v = process(v)</span><br><span class="line">    <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      v.Send()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">  <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;</span><br><span class="line">    log.Printf(<span class="string">"Invalid v: %v"</span>, v)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v = process(v)</span><br><span class="line">  <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  v.Send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="不必要的-else"><a href="#不必要的-else" class="headerlink" title="不必要的 else"></a>不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">  a = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="顶层变量声明"><a href="#顶层变量声明" class="headerlink" title="顶层变量声明"></a>顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s <span class="keyword">string</span> = F()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _s = F()</span><br><span class="line"><span class="comment">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型</span></span><br><span class="line"><span class="comment">// 还是那种类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"A"</span> &#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="string">"error"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span> <span class="title">myError</span></span> &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _e error = F()</span><br><span class="line"><span class="comment">// F 返回一个 myError 类型的实例，但是我们要 error 类型</span></span><br></pre></td></tr></table></figure><h3 id="对于未导出的顶层常量和变量，使用-作为前缀"><a href="#对于未导出的顶层常量和变量，使用-作为前缀" class="headerlink" title="对于未导出的顶层常量和变量，使用_作为前缀"></a>对于未导出的顶层常量和变量，使用_作为前缀</h3><p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p><p>例外：未导出的错误值，应以<code>err</code>开头。</p><p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  defaultPort = <span class="number">8080</span></span><br><span class="line">  defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">  defaultPort := <span class="number">9090</span></span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(<span class="string">"Default port"</span>, defaultPort)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We will not see a compile error if the first line of</span></span><br><span class="line">  <span class="comment">// Bar() is deleted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  _defaultPort = <span class="number">8080</span></span><br><span class="line">  _defaultUser = <span class="string">"user"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="结构体中的嵌入"><a href="#结构体中的嵌入" class="headerlink" title="结构体中的嵌入"></a>结构体中的嵌入</h3><p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">  http.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  http.Client</span><br><span class="line"></span><br><span class="line">  version <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="使用字段名初始化结构体"><a href="#使用字段名初始化结构体" class="headerlink" title="使用字段名初始化结构体"></a>使用字段名初始化结构体</h3><p>初始化结构体时，几乎始终应该指定字段名称。现在由 <a href="https://golang.org/cmd/vet/" target="_blank" rel="noopener"><code>go vet</code></a> 强制执行。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;<span class="string">"John"</span>, <span class="string">"Doe"</span>, <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := User&#123;</span><br><span class="line">    FirstName: <span class="string">"John"</span>,</span><br><span class="line">    LastName: <span class="string">"Doe"</span>,</span><br><span class="line">    Admin: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  op Operation</span><br><span class="line">  want <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;Add, <span class="string">"add"</span>&#125;,</span><br><span class="line">  &#123;Subtract, <span class="string">"subtract"</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本地变量声明"><a href="#本地变量声明" class="headerlink" title="本地变量声明"></a>本地变量声明</h3><p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"foo"</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"foo"</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  filtered := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(list []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> filtered []<span class="keyword">int</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> list &#123;</span><br><span class="line">    <span class="keyword">if</span> v &gt; <span class="number">10</span> &#123;</span><br><span class="line">      filtered = <span class="built_in">append</span>(filtered, v)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="nil-是一个有效的-slice"><a href="#nil-是一个有效的-slice" class="headerlink" title="nil 是一个有效的 slice"></a>nil 是一个有效的 slice</h3><p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，</p><ul><li><p>您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="string">""</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table></li><li><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table></li><li><p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// or, nums := make([]int)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add1 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> add2 &#123;</span><br><span class="line">  nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table></li></ul><h3 id="小变量作用域"><a href="#小变量作用域" class="headerlink" title="小变量作用域"></a>小变量作用域</h3><p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="#减少嵌套">减少嵌套</a>的规则冲突。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := ioutil.WriteFile(name, data, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := ioutil.WriteFile(name, data, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> data, err := ioutil.ReadFile(name); err == <span class="literal">nil</span> &#123;</span><br><span class="line">  err = cfg.Decode(data)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fmt.Println(cfg)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data, err := ioutil.ReadFile(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cfg.Decode(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(cfg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="避免参数语义不明确-Avoid-Naked-Parameters"><a href="#避免参数语义不明确-Avoid-Naked-Parameters" class="headerlink" title="避免参数语义不明确(Avoid Naked Parameters)"></a>避免参数语义不明确(Avoid Naked Parameters)</h3><p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func printInfo(name string, isLocal, done bool)</span></span><br><span class="line"></span><br><span class="line">printInfo(<span class="string">"foo"</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Region <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  UnknownRegion Region = <span class="literal">iota</span></span><br><span class="line">  Local</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  StatusReady = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">  StatusDone</span><br><span class="line">  <span class="comment">// Maybe we will have a StatusInProgress in the future.</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="keyword">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure><h3 id="使用原始字符串字面值，避免转义"><a href="#使用原始字符串字面值，避免转义" class="headerlink" title="使用原始字符串字面值，避免转义"></a>使用原始字符串字面值，避免转义</h3><p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit" target="_blank" rel="noopener">原始字符串字面值</a>，也就是 “ ` “ 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p><p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">"unknown name:\"test\""</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wantError := <span class="string">`unknown error:"test"`</span></span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="初始化-Struct-引用"><a href="#初始化-Struct-引用" class="headerlink" title="初始化 Struct 引用"></a>初始化 Struct 引用</h3><p>在初始化结构引用时，请使用<code>&amp;T{}</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inconsistent</span></span><br><span class="line">sptr := <span class="built_in">new</span>(T)</span><br><span class="line">sptr.Name = <span class="string">"bar"</span></span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sval := T&#123;Name: <span class="string">"foo"</span>&#125;</span><br><span class="line"></span><br><span class="line">sptr := &amp;T&#123;Name: <span class="string">"bar"</span>&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="初始化-Maps"><a href="#初始化-Maps" class="headerlink" title="初始化 Maps"></a>初始化 Maps</h3><p>对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的。<br>这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="keyword">map</span>[T1]T2&#123;&#125;</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  <span class="comment">// m1 读写安全;</span></span><br><span class="line">  <span class="comment">// m2 在写入时会 panic</span></span><br><span class="line">  m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2)</span><br><span class="line">  m2 <span class="keyword">map</span>[T1]T2</span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr><tr><td><p>声明和初始化看起来非常相似的。</p></td><td><p>声明和初始化看起来差别非常大。</p></td></tr></tbody></table><p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a href="#尽量初始化时指定-Map-容量">尽量初始化时指定 Map 容量</a>。</p><p>另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, <span class="number">3</span>)</span><br><span class="line">m[k1] = v1</span><br><span class="line">m[k2] = v2</span><br><span class="line">m[k3] = v3</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[T1]T2&#123;</span><br><span class="line">  k1: v1,</span><br><span class="line">  k2: v2,</span><br><span class="line">  k3: v3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</p><h3 id="字符串-string-format"><a href="#字符串-string-format" class="headerlink" title="字符串 string format"></a>字符串 string format</h3><p>如果你为<code>Printf</code>-style 函数声明格式字符串，请将格式化字符串放在外面，并将其设置为<code>const</code>常量。</p><p>这有助于<code>go vet</code>对格式字符串执行静态分析。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg := <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = <span class="string">"unexpected values %v, %v\n"</span></span><br><span class="line">fmt.Printf(msg, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><h3 id="命名-Printf-样式的函数"><a href="#命名-Printf-样式的函数" class="headerlink" title="命名 Printf 样式的函数"></a>命名 Printf 样式的函数</h3><p>声明<code>Printf</code>-style 函数时，请确保<code>go vet</code>可以检测到它并检查格式字符串。</p><p>这意味着您应尽可能使用预定义的<code>Printf</code>-style 函数名称。<code>go vet</code>将默认检查这些。有关更多信息，请参见 <a href="https://golang.org/cmd/vet/#hdr-Printf_family" target="_blank" rel="noopener">Printf 系列</a>。</p><p>如果不能使用预定义的名称，请以 f 结束选择的名称：<code>Wrapf</code>，而不是<code>Wrap</code>。<code>go vet</code>可以要求检查特定的 Printf 样式名称，但名称必须以<code>f</code>结尾。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> go vet -printfuncs=wrapf,statusf</span><br></pre></td></tr></table></figure><p>另请参阅 <a href="https://kuzminva.wordpress.com/2017/11/07/go-vet-printf-family-check/" target="_blank" rel="noopener">go vet: Printf family check</a>.</p><h2 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h2><h3 id="表驱动测试"><a href="#表驱动测试" class="headerlink" title="表驱动测试"></a>表驱动测试</h3><p>当测试逻辑是重复的时候，通过  <a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">host, port, err := net.SplitHostPort(<span class="string">"192.0.2.0:8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"192.0.2.0:http"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"192.0.2.0"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"http"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">":8000"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">""</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8000"</span>, port)</span><br><span class="line"></span><br><span class="line">host, port, err = net.SplitHostPort(<span class="string">"1:8"</span>)</span><br><span class="line">require.NoError(t, err)</span><br><span class="line">assert.Equal(t, <span class="string">"1"</span>, host)</span><br><span class="line">assert.Equal(t, <span class="string">"8"</span>, port)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func TestSplitHostPort(t *testing.T)</span></span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:8000"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"192.0.2.0:http"</span>,</span><br><span class="line">    wantHost: <span class="string">"192.0.2.0"</span>,</span><br><span class="line">    wantPort: <span class="string">"http"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">":8000"</span>,</span><br><span class="line">    wantHost: <span class="string">""</span>,</span><br><span class="line">    wantPort: <span class="string">"8000"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    give:     <span class="string">"1:8"</span>,</span><br><span class="line">    wantHost: <span class="string">"1"</span>,</span><br><span class="line">    wantPort: <span class="string">"8"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    host, port, err := net.SplitHostPort(tt.give)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    assert.Equal(t, tt.wantHost, host)</span><br><span class="line">    assert.Equal(t, tt.wantPort, port)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p><p>我们遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">  give     <span class="keyword">string</span></span><br><span class="line">  wantHost <span class="keyword">string</span></span><br><span class="line">  wantPort <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="功能选项"><a href="#功能选项" class="headerlink" title="功能选项"></a>功能选项</h3><p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p><p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p><table><thead><tr><th>Bad</th><th>Good</th></tr></thead><tbody><tr><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package db</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeout time.Duration,</span></span></span><br><span class="line"><span class="function"><span class="params">  caching <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Timeout and caching must always be provided,</span></span><br><span class="line"><span class="comment">// even if the user wants to use the default.</span></span><br><span class="line"></span><br><span class="line">db.Connect(addr, db.DefaultTimeout, db.DefaultCaching)</span><br><span class="line">db.Connect(addr, newTimeout, db.DefaultCaching)</span><br><span class="line">db.Connect(addr, db.DefaultTimeout, <span class="literal">false</span> <span class="comment">/* caching */</span>)</span><br><span class="line">db.Connect(addr, newTimeout, <span class="literal">false</span> <span class="comment">/* caching */</span>)</span><br></pre></td></tr></table></figure></td><td><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> options <span class="keyword">struct</span> &#123;</span><br><span class="line">  timeout time.Duration</span><br><span class="line">  caching <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option overrides behavior of Connect.</span></span><br><span class="line"><span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;</span><br><span class="line">  apply(*options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> optionFunc <span class="function"><span class="keyword">func</span><span class="params">(*options)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f optionFunc)</span> <span class="title">apply</span><span class="params">(o *options)</span></span> &#123;</span><br><span class="line">  f(o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(t time.Duration)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> optionFunc(<span class="function"><span class="keyword">func</span><span class="params">(o *options)</span></span> &#123;</span><br><span class="line">    o.timeout = t</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCaching</span><span class="params">(cache <span class="keyword">bool</span>)</span> <span class="title">Option</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> optionFunc(<span class="function"><span class="keyword">func</span><span class="params">(o *options)</span></span> &#123;</span><br><span class="line">    o.caching = cache</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect creates a connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  addr <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  opts ...Option,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*Connection, error)</span></span> &#123;</span><br><span class="line">  options := options&#123;</span><br><span class="line">    timeout: defaultTimeout,</span><br><span class="line">    caching: defaultCaching,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">    o.apply(&amp;options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Options must be provided only if needed.</span></span><br><span class="line"></span><br><span class="line">db.Connect(addr)</span><br><span class="line">db.Connect(addr, db.WithTimeout(newTimeout))</span><br><span class="line">db.Connect(addr, db.WithCaching(<span class="literal">false</span>))</span><br><span class="line">db.Connect(</span><br><span class="line">  addr,</span><br><span class="line">  db.WithCaching(<span class="literal">false</span>),</span><br><span class="line">  db.WithTimeout(newTimeout),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>还可以参考下面资料：</p><ul><li><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self-referential functions and the design of options</a></li><li><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">Functional options for friendly APIs</a></li></ul><!-- TODO: replace this with parameter structs and functional options, when touse one vs other -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文长期维护地址: &lt;a href=&quot;https://github.com/xxjwxc/uber_go_guide_cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xxjwxc/uber_go_guide_cn&lt;
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://razertory.me/tags/Golang/"/>
    
  </entry>
  
</feed>
